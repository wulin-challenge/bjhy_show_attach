<=====================================================================================================================================================================>
在java 的 eclipse的debug模式中如何使用快捷键查看一个被选中的值:

	ctrl+shift+i

<=====================================================================================================================================================================>
java的反编译器:

	java decompiler

<=====================================================================================================================================================================>
在myeclipse中如何查看自己的快捷键:

	ctrl+shift+l
	
<=====================================================================================================================================================================>
常用的MyEclipse的快捷键

	ctrl+e : 显示所有的tab列表

<=====================================================================================================================================================================>
基本类型不用写包名，而包装类型要写包名，除此之外，日期也要写上包名；
&nbsp;

<=====================================================================================================================================================================>

在同一个方法中两次以上抛出同一个异常的方法:

public void welcomeHouse(Customer customer) throws TheRoomCanNotHelpCustomers{
		try {
			int flag=1;
			CustomerRoom customerRoom=customerDao.findIdByRealRoomNumber(customer);
			if(customerRoom.getFlag()==1){
				throw new TheRoomCanNotHelpCustomers();
			}
			customer.setVid(customerRoom.getId());
			customerDao.updateRoomById(flag,customerRoom);
			customerDao.welcomeHouse(customer);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new TheRoomCanNotHelpCustomers();
		}
	}


<=====================================================================================================================================================================>
如何创建一个空的集合:

	//return new ArrayList<T>(); 或
			return Collections.EMPTY_LIST; //返回一个空集合.但是这个集合是不可以用的,即只适合用来判断,不能向里面添加元素 

<=====================================================================================================================================================================>

如何得到带有泛型参数的字节码真实对象:

	public class BaseDaoImpl<T,K,D> implements BaseDao<T> {
		
		private Class<T> clazz;
	
		public BaseDaoImpl(){
			ParameterizedType pt=(ParameterizedType) this.getClass().getGenericSuperclass();//得到带有泛型参数的字节码对象
			this.clazz=(Class<T>) pt.getActualTypeArguments()[0];//得到第一个泛型参数的真实字节码对象
		}

	}

	方式二:

		public class BaseDaoImpl<T> implements BaseDao<T>{
			private Class<?> clazz;
			public BaseDaoImpl(T entity) {
			clazz=entity.getClass();
			System.out.println(clazz);
			}
		}


<=====================================================================================================================================================================>
关于base64码的操作:

	public static void main(String[] args) {  
		// 测试从图片文件转换为Base64编码  
	    String imageStr =  GetImageStr("d:\\dress8.png");  
	    System.out.println(imageStr);
		// 测试从Base64编码转换为图片文件  
		//String strImg = "这里放64位编码";  
		GenerateImage(imageStr, "D:\\dress88.jpg");  
	}
	
	/**
	 * 将图片转换为base64编码
	 * @param imgFilePath 图片的输出路径
	 * @return
	 */
	public static String GetImageStr(String imgFilePath) {	// 将图片文件转化为字节数组字符串，并对其进行Base64编码处理//这个方式在使用URL在网络中获取资源时,
															//自能获取资源大小为10k一下的,与资源打印10k的获取另外看自己储备的其他文档
		byte[] data = null;

		// 读取图片字节数组
		try {
			InputStream in = new FileInputStream(imgFilePath);
			data = new byte[in.available()];
			in.read(data);
			in.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

		// 对字节数组Base64编码
		BASE64Encoder encoder = new BASE64Encoder();
		return encoder.encode(data);// 返回Base64编码过的字节数组字符串
	}
	
	/**
	 * 将图片转换为base64编码
	 * @param imgFilePath 图片的输出路径
	 * @return
	 */
	private String getImgToBase64(String _path) { //可以转换很大的文件或图片
		String path = _path;
		System.out.println("path : "+path);
		int BYTE_SIZE = 1;
		int SAVE_SIZE = 1024;
		byte[] buff = new byte[BYTE_SIZE]; // 每次读的缓存
		byte[] save = new byte[SAVE_SIZE]; // 保存前缓存
		byte[] imgByte = null;
		String imgStr = null;
		BufferedInputStream bf = null;
		List<byte[]> byteList = null;
		try {
			byteList = new ArrayList<byte[]>();
			// 对字节数组Base64编码
			BASE64Encoder encoder = new BASE64Encoder();

			File file = new File(path);
			InputStream is = new FileInputStream(file);
			bf = new BufferedInputStream(is);
			int i = 0;
			while (bf.read(buff) != -1) { // 一个字节一个字节读
				save[i] = buff[0];
				if (i == SAVE_SIZE - 1) { // 达到保存长度时开始保存
					// 返回Base64编码过的字节数组字符串
					byteList.add(save);
					save = new byte[SAVE_SIZE];
					i = 0;
				} else {
					i++;
				}
			}
			// 最后这段如果没达到保存长度，需要把前面的保存下来
			if (i > 0) {
				// 返回Base64编码过的字节数组字符串
				byteList.add(save);
			}
			int length = byteList.size();
			imgByte = new byte[SAVE_SIZE * (length - 1) + i];
			for (int j = 0; j < byteList.size() - 1; j++) {
				byte[] temp = byteList.get(j);
				System.arraycopy(temp, 0, imgByte, j * SAVE_SIZE, SAVE_SIZE);
			}
			if (i > 0) {
				System.arraycopy(save, 0, imgByte, (length - 1) * SAVE_SIZE, i);
			}
			imgStr = encoder.encode(imgByte);

		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				bf.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return imgStr;
	}

	/**
	 * 将经base64编码字符串转换为图片
	 * @param imgStr 经base64编码过后的字符串
	 * @param imgFilePath 图片输出路径
	 * @return
	 */
	public static boolean GenerateImage(String imgStr, String imgFilePath) {// 对字节数组字符串进行Base64解码并生成图片
		if (imgStr == null) // 图像数据为空
			return false;
		BASE64Decoder decoder = new BASE64Decoder();
		try {
			// Base64解码
			byte[] bytes = decoder.decodeBuffer(imgStr);
			for (int i = 0; i < bytes.length; ++i) {
				if (bytes[i] < 0) {// 调整异常数据
					bytes[i] += 256;
				}
			}
			// 生成jpeg图片
			OutputStream out = new FileOutputStream(imgFilePath);
			out.write(bytes);
			out.flush();
			out.close();
			return true;
		} catch (Exception e) {
			return false;
		}
	}
	
	//通过byte[]数组得到流
	public static InputStream byteTOInputStream(byte[] in) throws Exception{  
        ByteArrayInputStream is = new ByteArrayInputStream(in);  
        return is;  
    }
	
	//通过base64码字符串得到byte数组
	public static byte[] decoderBase64File(String base64Code)throws Exception {
		 return new BASE64Decoder().decodeBuffer(base64Code);
	}
	
	//通过base64字符串得到流
	public static InputStream decoderBase64FileToInputStream(String base64Code)throws Exception {
		 return new ByteArrayInputStream(new BASE64Decoder().decodeBuffer(base64Code));
	}
	
	/**
     * 将byte[] 数组转为base64的字符串
     * @param b
     * @return
     */
    public static String getBase64ByByteArray(byte[] b){
    	 BASE64Encoder encoder = new BASE64Encoder();
 		String base64 = encoder.encode(b);// 返回Base64编码过的字节数组字符串
 		return base64;
    }
	
	/** 
     * 获得InputStream的byte数组 
     */  
	private byte[] getBytes(InputStream is) {
		byte[] buffer = null;
		ByteArrayOutputStream bos = new ByteArrayOutputStream(1000);
		byte[] b = new byte[1000];
		try {
			int n = 0;
			while ((n = is.read(b)) != -1) {
				bos.write(b, 0, n);
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				is.close();
				bos.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		buffer = bos.toByteArray();
		return buffer;
	}

<=====================================================================================================================================================================>
java删除某个文件夹及该文件夹下的所有文件及文件夹
	/**
	 * 删除某个文件夹及该文件夹下的所有文件及文件夹
	 * @param delpath
	 * @return
	 * @throws Exception
	 */
	public static boolean deleteFile(String delpath) throws Exception{
		try {
			delpath = delpath.replace("\\\\", "/"); //// Java中4个反斜杠表示一个反斜杠
			delpath = delpath.replace("\\", "/"); 
			File file = new File(delpath);
			// 当且仅当此抽象路径名表示的文件存在且 是一个目录时，返回 true
			if (!file.isDirectory()) {
				file.delete();
			} else if (file.isDirectory()) {
				String[] filelist = file.list();
				for (int i = 0; i < filelist.length; i++) {
					File delfile = new File(delpath + "/" + filelist[i]);
					if (!delfile.isDirectory()) {
						delfile.delete();
						System.out
								.println(delfile.getAbsolutePath() + "删除文件成功");
					} else if (delfile.isDirectory()) {
						deleteFile(delpath + "/" + filelist[i]);
					}
				}
				System.out.println(file.getAbsolutePath() + "删除成功");
				file.delete();
			}

		} catch (FileNotFoundException e) {
			System.out.println("deletefile() Exception:" + e.getMessage());
		}
		return true;
	}

<=====================================================================================================================================================================>
java输出某个文件夹下的所有文件夹和文件路径 

	 public boolean readfile(String filepath)  
		   throws FileNotFoundException, IOException {  
		  try {  
		  
		   File file = new File(filepath);  
		   System.out.println("遍历的路径为：" + file.getAbsolutePath());  
		   // 当且仅当此抽象路径名表示的文件存在且 是一个目录时（即文件夹下有子文件时），返回 true  
		   if (!file.isDirectory()) {  
			System.out.println("该文件的绝对路径：" + file.getAbsolutePath());  
			System.out.println("名称：" + file.getName());  
		   } else if (file.isDirectory()) {  
			// 得到目录中的文件和目录  
			String[] filelist = file.list();  
			if (filelist.length == 0) {  
			 System.out.println(file.getAbsolutePath()  
			   + "文件夹下，没有子文件夹或文件");  
			} else {  
			 System.out  
			   .println(file.getAbsolutePath() + "文件夹下，有子文件夹或文件");  
			}  
			for (int i = 0; i < filelist.length; i++) {  
			 File readfile = new File(filepath + "\\" + filelist[i]);  
			 System.out.println("遍历的路径为：" + readfile.getAbsolutePath());  
			 if (!readfile.isDirectory()) {  
			  System.out.println("该文件的路径："  
				+ readfile.getAbsolutePath());  
			  System.out.println("名称：" + readfile.getName());  
			 } else if (readfile.isDirectory()) {  
			  System.out.println("-----------递归循环-----------");  
			  readfile(filepath + "\\" + filelist[i]);  
			 }  
			}  
		  
		   }  
		  
		  } catch (FileNotFoundException e) {  
		   System.out.println("readfile() Exception:" + e.getMessage());  
		  }  
		  return true;  
		 }  
		 
<=====================================================================================================================================================================>
java中如何获得计算机的硬盘更目录:

	File [] root = File.listRoots(); 

		for(File file : root) 
		{ 
		  System.out.println(file.getAbsolutePath()); 
		} 

<=====================================================================================================================================================================>
java创建文件目录与创建文件的案例:

	File [] root = File.listRoots(); 
			if(root.length >0){
					File file = root[0];
					dir = file.getAbsolutePath();
					dir = dir.substring(0, dir.length()-1)+"/";
					
					dir = dir+"temp/uploadFile/"+UUID.randomUUID().toString()+"/";
					
					String fileName1 = doc.getsDocName().substring(0, doc.getsDocName().lastIndexOf("."))
					+"_1"+doc.getsDocName().substring(doc.getsDocName().lastIndexOf("."));
					System.out.println("fileName : "+fileName1);
					
					File outPutFile =new File(dir); //一下这三行代码为创建文件
					if(!outPutFile.exists()){
						outPutFile.mkdirs();
					}
					String path = dir+fileName1;
					System.out.println(path);
					try {
						doc.download(new FileOutputStream(path)); //输入到某个文件中,该文件可以是不存在,不存在就创建
					} catch (FileNotFoundException e) {
						e.printStackTrace();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
			
<=====================================================================================================================================================================>
在java web 如何服务器的分隔符

	获取文件分隔符方式: File.separator ;
	
	例如:

	realPath = request.getSession().getServletContext().getRealPath("")
				+ File.separator; // 取得服务器路径
				
<=====================================================================================================================================================================>
java反斜杠\的用法

	java反斜杠\的用法比较怪异，分为两种场景：
	1. 正则表达式 
		 匹配点(.) 或  {、[、(、?、$、^ 、+和 * 这些特殊符号要要前加双斜框，表示字符类的时候也是用双斜杠譬如（\\s[空白符], \\S, \\d, \\D, \\w, \\W），匹配 \ 时要用四斜杠
	2. 字符串
		譬如\n, \t, \r 回车换行tap之类的只要一个反斜杠即可，在字符串中表示一个反斜杠只用两个反斜杠即可 \\

	顺带提一下String.replace 和replaceAll的区别，前者是匹配字符串替换，后者是匹配正则表达式替换
	相同点是：都是对源字符串的全部替换

	String s ="sdf\\a\\aa";
	System.out.println(s);
	System.out.println(s.replaceAll("\\\\", "\\\\\\\\"));
	System.out.println(s.replace("\\", "\\\\"));
	这两种替换的结果都是 sdf\\a\\aa
	源码剖析：
	public String replaceAll(String regex, String replacement) {
			return Pattern.compile(regex).matcher(this).replaceAll(replacement);
		}

	 public String replace(CharSequence target, CharSequence replacement) {
			return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(
					this).replaceAll(Matcher.quoteReplacement(replacement.toString()));
		}

	replace比replaceall多了quoteReplacement，这个函数就是把字符串中出现\或者$的前面再添加一个\, 这样的话s.replace("\\", "\\\\")其实后台处理也是八个\

	最简单的就是这样记住，在正则表达式中用4个\表示一个\

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
将反斜杠改变为整斜杠

	 public static String transformation(String path){
    	path = path.replace("\\\\", "/");
    	path = path.replace("\\", "/");
    	return path; //Java中4个反斜杠表示一个反斜杠
    }

<=====================================================================================================================================================================>
java中的正直表达如何将特殊字符当 普通字符进行匹配

	public static void main(String[] args) {
		
		String sqlTemplate = "select ${columnsOfTable} from ${tableName} ${afterTable}";
	//	String sqlTemplate = "select columnsOfTable from tableName afterTable";
		sqlTemplate = sqlTemplate.replaceAll("\\$\\{columnsOfTable\\}","2222" );
		System.out.println(sqlTemplate);
	}

<=====================================================================================================================================================================>










<=====================================================================================================================================================================>
在同一个页面中,javaScript代码一般放在jsp代码的后面,否则,有可能会出错

<=====================================================================================================================================================================>

对数组的理解:

一旦定义了数组,就要为数组创建一个对象并指定大小 , 其实在用之前创建对象并将该对象赋予给所定义的数组就可以了

扩展:

	其实其他对象也是一样的,就是在定义了一个引用变量后,都要在用该应用变量之前创建一个对象并将该对象赋予给这个引用变量,否则就会抛出空指针异常



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

对数组的正确做法:

public StudentArrays findStudents() {
		String[] studentOne=new String[]{"id","name","password","gender","identityNumber","registerDate"};
		List<Student> studentList=registerDao.findStudents();
		String[][] studentTwo=new String[studentList.size()][studentOne.length];
		int i=0;
		for (Student student : studentList) {
			studentTwo[i][0]=student.getId()+"";
			studentTwo[i][1]=student.getName();
			studentTwo[i][2]=student.getPassword();
			studentTwo[i][3]=student.getGender();
			studentTwo[i][4]=student.getIdentityNumber();
			studentTwo[i][5]=DateFormat.getDateInstance().format(student.getRegisterDate());
			i++;
		}
		StudentArrays sa=new StudentArrays();
		sa.setStudentOne(studentOne);
		sa.setStudentTwo(studentTwo);
		return sa;
	}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

对数组的错误的做法:                    //这种情况下抛出空指针异常

public StudentArrays findStudents() {
		String[] studentOne=new String[]{"id","name","password","gender","identityNumber","registerDate"};
		List<Student> studentList=registerDao.findStudents();
		String[][] studentTwo=null;     //没有为二维数组创建一个对象并指定大小,抛出空指针异常

		int i=0;
		for (Student student : studentList) {
			studentTwo[i][0]=student.getId()+"";
			studentTwo[i][1]=student.getName();
			studentTwo[i][2]=student.getPassword();
			studentTwo[i][3]=student.getGender();
			studentTwo[i][4]=student.getIdentityNumber();
			studentTwo[i][5]=DateFormat.getDateInstance().format(student.getRegisterDate());
			i++;
		}
		StudentArrays sa=new StudentArrays();
		sa.setStudentOne(studentOne);
		sa.setStudentTwo(studentTwo);
		return sa;
	}


<=====================================================================================================================================================================>



<=====================================================================================================================================================================>

super.getClass()方法调用

下面程序的输出结果是多少？

import java.util.Date;

public  class Test extends Date{

public static void main(String[] args) {

new Test().test();

}

 

public void test(){

System.out.println(super.getClass().getName());

}

}

 

     很奇怪，结果是Test

     这属于脑筋急转弯的题目，在一个qq群有个网友正好问过这个问题，我觉得挺有趣，就研究了一下，没想到今天还被你面到了，哈哈。

     在test方法中，直接调用getClass().getName()方法，返回的是Test类名

     由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在

     test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用this.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。

     如果想得到父类的名称，应该用如下代码：

     this.getClass().getSuperClass().getName();

<=====================================================================================================================================================================>
对jdk,jre,jvm,path,classPath 的理解:

	



<=====================================================================================================================================================================>
关于内部类中如果使用成员变量与局部变量:

	在一个类中的方法中的匿名内部类中可以直接使用外部类中的成员变量,但不可以直接使用所在方法中局部变量,若要使用方法中的局部变量,则需要在该声明局部变量前用 final 修	
       
        饰

<=====================================================================================================================================================================>

在同一个类中的同名的成员变量与局部变量:

       在一个类中,方法中的局部变量可以与类中的成员变量相同,若方法中直接使用该变量,则该变量只能是局部变量,若要是用同名的成员变量,这需要用this.引用变量


<=====================================================================================================================================================================>

静态方法中如何使用成员变量:

	静态方法中若想使用成员变量,则该成员变量也必须是静态的.当然非静态方法中也可以直接使用静态成员变量

<=====================================================================================================================================================================>

用类名调用成员变量或成员方法的理解:

	当用类名调用静态成员方法或静态成员变量,不管用该类对象调用成员方法或成员变量多少次,该类对象始终都是同一个.

<=====================================================================================================================================================================>

对成员变量与全局变量与线程安全的理解:

	其实成员变量也就是全局变量,那为什么 全局变量会与线程安全 扯上关系呢?那是因为java的 运行其实分为 编译 与运行 两个过程,一个java程序要真正的运行就必须先经过编译,
	编译其实也是一种运行,只是编译走的 类成员,而运行则是按照我所给定的条件走,  因而当运行时多个线程 共享 同一个对象中的成员变量时 就会发生线程安全问题,


<=====================================================================================================================================================================>

对在java编程中两张表及两张表以上标间关联与映射的理解:

	示例:  部门(department) 与 员工(employees) 

	  	部门与员工是一对多的映射关系,因此员工方需要一列应用部门表的唯一键列,而在java编程中.我们通常会有这样的需求,那就是在部门的javabean中我们需要的所有的员工                  信息,通过员工的javabean我们也希望得到自己对应部门的所有信息,因此我们需要在部门的javabean中写上 'private List<Emloyee> emloyeeList' ;而在员工的javabean
		中加上private Department department ;而在dao中的 sql 语句则就是利用表与表的 等值关联 得到两张表中我们想得到的信息.

<=====================================================================================================================================================================>

对gui中组件 与 对象的理解:

	其实在gui创建一个组件就是创建一个对象,即在java虚拟机中的堆内存中为该对象分配一定的内存空间,同时将该对象用特定可显示的方式在窗体中显示出来,当我们创建了两个样式        相同组件(实际是两个不同的对象)或不同组件(即也是两个不同对象)在窗体中的同一个位置显示出来,这时窗体在显示着两个组件(即对象)时就会产生混乱,即窗体不知道该怎么显示
	因为两个不同的对象间 不存在 覆盖于被覆盖的关系 .所以在编程我们要对我们创建出来的对象负责,一定要清楚我们创建出来的对象都用来干嘛了,这些对象的生命周期是从什么地        方开始,到什么地方结束, 特别是在 gui编程中更是要注意,不能够乱创建组件(即对象),更不能想当然的将后创建出来的组件(即对象)去覆盖前创建的组件(即对象),这样只会造成窗          体显示混乱,绝对得不到你所期待的结果.

<=====================================================================================================================================================================>

对匿名内部类的与监听器的理解:

	匿名内部类是定义在方法的参数中且一般只使用一次,使用方法见参考书 "java疯狂SE" 中的讲解,而java 中gui部分所说的监听器有时这么一回事了,其实gui中创建一个组件就是创         建一个该组件所属类的一个对象,而所谓监听就是当该组件接收到了一个 '行为',就让该对象根据 '行为' 去调用不同的方法, 那么为什么将监听 与 匿名内部类 组合在一起使用            呢? 那是因为同一个对象根据 相同 '行为' 去调用的都是相同的方法,但是同一个 '行为' 里的内容又可能不同,而该内容又只需要 仅仅 使用一次,而匿名内部类又恰恰满足这个要求
	所有 gui 中的 监听 与 匿名内部类 是一对完美的组合 ,


<=====================================================================================================================================================================>

对基本类型的变量与应用类型的变量的初始化的理解:

	当我们定义了一个基本类型的变量或一个引用类型的变量是,如果该基本类型的变量或引用变量未被赋予初值,则在系统进行编译时就会报错,因为系统不会自动为基本类型的变量或引用类型的引用变量赋予初值 0或null.

<=====================================================================================================================================================================>

对try--catch 的理解与使用:

	当一个语句被 try--catch 所环绕后,如果当程序运行时在该语句处发生了异常,那么该异常就会被catch所截获,并且在catch所在域中结束当前分支进程.

<=====================================================================================================================================================================>

java中流的分类?流这部分用到什么设计模式?

	按流向:输入流.输出流
	按功能:节点流.处理流
	按大小:字节流.字符流
		用到了装饰设计模式
<=====================================================================================================================================================================>
常见的几个RuntimeExce:

	空指针异常,引索越界异常,类型转换异常,没有类异常,systemException,emptystackexception.

<=====================================================================================================================================================================> 
如何得到一个工程中放在src根目录下的路劲:

	String path=ParseXmlUtil.class.getClass().getResource("/my-base-mapping.xml").getPath();  //这个是在非static方法中使用

	String path=this.class.getClass().getResource("/my-base-mapping.xml").getPath();  //这个是在非方法中使用,因为用了this

	String path =Thread.currentThread().getContextClassLoader().getResource("my-base-mapping.xml").getPath();  
	
	........................................................................................................................................
	
			// 从classpath的根目录中查找a.txt文件
		this.getClass().getClassLoader().getResourceAsStream("a.txt");

		// 从classpath的根目录中查找a.txt文件
		this.getClass().getResourceAsStream("/a.txt");

		// 从当前类所在的包中查找a.txt文件
		this.getClass().getResourceAsStream("a.txt");

	//这个是在static方法中使用,当然亦可以在非static方法中使用

<=====================================================================================================================================================================> 
如何用cmd命令查找正在运行的进程

	1.使用netstat -ano 命令
	2.找到该进程对应的端口号,
	3.找到该端口号对应的PID号
	4.打开任务管理器,点击  '查看'/'选择'
	5.勾选PID选项,然后再进程中找到PID号与cmd的PID号相同的进程,将其结束

<=====================================================================================================================================================================> 
异常积累：org.springframework.dao.InvalidDataAccessApiUsageException: Write operations are not allowed in read-only mode （转载）

转载:文章来源：http://lucky16.iteye.com/blog/673903

此异常是由于Spring提供的Open Session In View而引起的。
开启OpenSessionInViewFilter这个过滤器的时候FlushMode就已经被默认设置为了MANUAL，如果FlushMode是MANUAL或NEVEL,在操作过程中 hibernate会将事务设置为readonly，所以在增加、删除或修改操作过程中会出现该错误 
<filter>  
       <filter-name>hibernateFilter</filter-name>  
       <filter-class>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter</filter-class>  
          <init-param>  
               <param-name>flushMode</param-name>  
               <param-value>AUTO</param-value>  
           </init-param> 
       <init-param>  
           <param-name>singleSession</param-name>  
           <param-value>true</param-value>  
       </init-param>  
   </filter>  
   <filter-mapping>  
       <filter-name>hibernateFilter</filter-name>  
       <url-pattern>/*</url-pattern>  
   </filter-mapping> 

<=====================================================================================================================================================================> 


































































































<=====================================================================================================================================================================>
     以上不懂的java代码解释
<=====================================================================================================================================================================>
<=====================================================================================================================================================================>
     以下是常用但又没有记清楚的java代码
<=====================================================================================================================================================================>

jdbc的作用:  是java连接数据库的一个标准

--------------------------------------------------------------------------------------------

jdbc的理论:
	1.PreparedStatement 是 statement的子接口
	2.PreparedStatement 使用的预编译,且效率比statement高

	execute():boolean   //这个方法可以(insert,update,delete,select)
	executeUpdate():int     //这个方法可以(insert,update,delete)
	executeQuery():ResultSet   //这个方法可以(select)

--------------------------------------------------------------------------------------------

当用execute做select操作是,应

	boolean flag=ps.execute();   //当flag为true时表示有结果集返回

	if(flag){
	rs=ps.getResultSet();
	}

--------------------------------------------------------------------------------------------
当我们要获得表中列数据时,可以用这个类 ResultSetmetaData 

--------------------------------------------------------------------------------------------
什么是runtimeException 异常:  runtimeException 是一种可处理,也可以不处理的异常
	
--------------------------------------------------------------------------------------------
事务:保证两个或两个以上的操作同时完成或取消

	connection.setAutoCommit(false);  //在jdbc中事务默认为自动提交,上述表示将自动提交设置为手动提交
	connection.commit();  提交
	connection.rollback();  回滚


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

oracle 的 jdbc的操作步骤


		//1.加载驱动
		Class.forName("oracle.jdbc.driver.OracleDriver");
		//2.获取连接
		Connection connection=DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl","scott","tiger");
		//3.准备sql语句
		String sql="INSERT INTO t_student(id,name,sex) values(1,'haha','男')";
		//4.准备PreparedStatement
		PreparedStatement ps=connection.prepareStatement(sql);
		//5.执行语句
		ps.execute();
		//5.1若是查询:
		ResultSet rs=ps.executeQuery();
		//5.2处理结果集
		...
		//6.关闭连接
		ps.close();
		connection.close();

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

插入与查询范例:

   插入:

       public static void insert(Student student){
		Connection connection=null;
		PreparedStatement ps=null;
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			connection=DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl","scott","tiger");
			String sql="INSERT INTO t_student(id,name,sex) values(?,?,?)";
			ps=connection.prepareStatement(sql);
			ps.setInt(1, student.getId());
			ps.setString(2,student.getName());
			ps.setString(3, student.getSex());
                        ps.setDate(6, new java.sql.Date(student.getRegisterDate().getTime()));
			ps.execute();
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			if(ps!=null){
				try {
					ps.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(connection!=null){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

	.....

	String sql="SELECT * FROM t_studentRegister WHERE id=?";
			ps=connection.prepareStatement(sql);
			ps.setInt(1,id);
			rs=ps.executeQuery();
			while(rs.next()){
				int i=rs.getInt("id");
				String name=rs.getString("name");
				String password=rs.getString("password");;
				java.sql.Date registerDate=rs.getDate("registerDate");
				
				Student student=new Student();
				student.setId(i);
				student.setRegisterDate(registerDate);
				studentList.add(student);
			}
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			DBConnection.close(rs, ps, connection);
		}

-----------------------------------------------------------

	注意:如果sql语句是 :   String sql="SELECT max(id) FROM t_patient"; 则在写得到结果集是也应 这样写 :String id=rs.getString("max(id)"); 其他同理.

<=====================================================================================================================================================================>

java.sql.Date与java.util.Date的转换:

		//java.sql.Date 与 java.sql.TimeStamp 都是接承 java.util.Date 的,即他两都是java.util.Date的子类

	java.util.Date date= new java.util.Date();
	long time=date.getTime();
	java.sql.Date sqlDate= new java.sql.Date(time);  //这个转换只带有年月日,没有时分秒
	java.sql.Timestamp timestamp=new java.sql.TimeStamp(time); //这个转换即带有年月日,也有时分秒 ,名字叫作时间戳
	

<=====================================================================================================================================================================>

关于java.util.Date的使用

	java.util.Date date= new java.util.Date();  //这个语句其实是将系统的年月日,时分秒都封装到所创建的对象中了


<=====================================================================================================================================================================>

关于动态更新的sql语句范例:

UPDATE t_student set name=?,sex=? where id=?

<=====================================================================================================================================================================>



<=====================================================================================================================================================================>

几种常用类型之间的相互转换:

7种基本类型之间的相互转换:

	byte--->short--->int--->long--->float--->double
	char--->int--->long--->float--->double
	箭头左边的数值型可以自动转换为右边的数值型,但箭头右边的数值型只能强转为左边的数值型,且要注意精度的 缺失.

将int 类型转换为Integer 类型:

	Integer i=new Integer(int i);

将integer 类型转换为Int 类型:

	Integer integer=new Integer(300);
	int i=integer.intValue();

将Sting转换为int:

        int i=Integer.parseInt(String str);

将Sting转换为integer:

	Integer i=Integer.decode(String str);

将字符数组转换为String类型的几种写法:  //可以转,但可能转完后可能加点号,谨慎使用

	String string=Arrays.toString(char[] char);

	String string=new String(char[] char);

将字符数组 char[] 转换为 String   //最常用 ,一般首选

	String str=String.valueOf(char[] ch);

	有时也可以用 String str=Arrays.toString(char[] ch);  //这个方法返回的是一个带有 逗号(,)分隔的字符串

--------------------------------------------------------------------------
对 String str=String.valueOf(数据类型 x);  //这里的数据类型可以是 int , long , float , doudle , char ,char[] , boolean 及Object (即可以是:Date ...等等引用数据类型)

--------------------------------------------------------------------------

将字符串数组String[] 转换为String ,目前我只会用迭代的方式:

	例如:

	                       String[] dateArray=dateString.split("-");
				String s=null;
				for (String string : dateArray) {
					if(s==null){
						s=string;
					}else{
						s=s+string;
					}
				}

------------------------------------------------------------------------------------------------------------------------------------------
将一个带有格式日期型的字符串 String 转换为日期型 Date

		Date date=null;
		String d="2014-12-21";
		DateFormat df=new SimpleDateFormat("yyyy-MM-dd");
			try {
				date=df.parse(d);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		System.out.println(df.format(date) );

------------------------------------------------------------------------------------------------------------------------------------------		

		Date date=null;
		String d="2014-12-21";
		DateFormat df=new SimpleDateFormat("yyyy-MM-dd");
		try {
			date=df.parse(d);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		DateFormat df3=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss EEE");  //带有格式的输出.
		System.out.println(df3.format(date) );
	
------------------------------------------------------------------------------------------------------------------------------------------

将一个符合日期型的字符串 String 转换为日期型 Date

	DateFormat dateFormat=DateFormat.getDateInstance();    // 注意这里应该是getDateInstance();
	java.util.Date date=null;
	try {
	date=dateFormat.parse(String str);        注意:这里的 str 应是 yyyy-MM-dd 格式的,否则将会抛出解析异常
	} catch (ParseException e1) {
		e1.printStackTrace();
	}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
这种将String 转换为 Date行的做法是错误的:    //将会抛出解析异常,因为这调用的getInstance();所以不对,而应该调用getDateInstance();才对

	try {
		Date date=DateFormat.getInstance().parse(difference.getText());
		student.setRegisterDate(date);
		} catch (ParseException e1) {
			e1.printStackTrace();
	            }

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


将一个日期 Date 型转换为String 类型:

	String str= DateFormat.getDateInstance().format(Date date) 
          将一个 Date 格式化为日期/时间字符串。 

    方法二:

	String string=String.valueOf(Date date);

------------------------------------------------------------------------------------


将一个日期 Date 型 按格式 转换为String 类型:

	关于这个转换,可以参考SimpleDateFormat 类

	范例:

		//在方法中创建日期
		Date date1=new Date();
		//创建不同的日期格式
		DateFormat df1=DateFormat.getInstance();
		System.out.println("按java默认的日期格式,默认的区域"+df1.format(date1));
		DateFormat df2=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss EEE");
		System.out.println(df2.format(date1));
		DateFormat df3=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss EEE");
		System.out.println(df3.format(date1));
		DateFormat df4=new SimpleDateFormat("yyyy年MM月dd日 hh时mm分ss秒  EE",Locale.CHINA);
		System.out.println(df4.format(date1));
		DateFormat df5=new SimpleDateFormat("yyyy-MM-dd");
		System.out.println(df5.format(date1));
		DateFormat df6=new SimpleDateFormat("yyyy年MM月dd日");
		System.out.println(df6.format(date1));
	
将java.util.Date 类型转换为java.sql.Date 类型的方法:

	java.util.Date date=new java.util.Date();
	long time=date.getTime();
	java.sql.Date sqlDate=new java.sql.Date(time);
	ps.setDate(6, sqlDate);

将java.sql.Date 类型转换为java.util.Date 类型的方法:

        //java.sql.Date 与 java.sql.TimeStamp 都是接承 java.util.Date 的,即他两都是java.util.Date的子类

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
将Object类型的数据转换为Integer的方法:

	在实际的Object类型的数据转换为Integer类型是不能直接转换的,因此我们只能借助String类型进行转换;即
	
	Object object=new Object();
	String str=(String)object();
	int i=Integer.parseInt(str);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
java计算百分比方法 :

	Integer perRowCoun = 3;
	Integer allCount = 15;
	Double perRowCoun2 = new Double(perRowCoun);
	Double allCount2 = new Double(allCount);  
	Double d = (double) (perRowCoun2/allCount2)*100;
	String percentage = String.format("%.2f", d);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
StringBuffer 与Stringz中常用的方法:         //String类是字符串常量,而StringBuffer类是字符串变量

	String str=new  String(StringBuffer buffer); 利用创建对象的方式将StringBuffer转换为String

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
以下方法属于String类
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	

	public char[] toCharArray(): 该方法将当前字符串常量转换为字符数组,并返回字符数组;
	
	public static String valueOf(基本数据类型  a);该方法将基本数据类型的变量转换为String 类的对象. 其中 '基本数据类型'包括 (boolean ,char ,int ,long ,float         ,double ,) .

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
以下方法属于StringBuffer类
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	StringBuffer stringBuffer=new StringBuffer();该构造方法创建一个空的StringBuffer类的对象.
	
	StringBuffer stringBuffer=new StringBuffer(String str);该构造方法用一个已经存在的字符串常量来创建一个StringBuffer类的对象.

	public String toString(): 该方法将StringBuffer类对象转换为String类对象并返回,

	public StringBuffer append(数据类型 a): 将数据类型的变量加到StringBuffer类的对象的后面.其中 '数据类型'包括(boolean,char,int,long,float,double,String,char[],)                                                    等数据类型

	public StringBuffer append(char ch[],int offset,int len): 该方法表示将字符数组str从第offset个开始取len个字符,追加到StringBuffer 类的对象的后面

	public StringBuffer insert(数据类型 a): 将数据类型的变量 a插入到StringBuffer 类的对象中的第offset个位置,其中 '数据类型'包括(oolean ,char ,int ,long                                                   ,float,double,String,char[],)等数据类型
	
	public int length():该方法返回字符串变量的长度,用法与String类的length()方法类似.

------------------------------------------------------------------------------------

关于将Object对象强转为其子类对象的问题:  当我们Object对象强转为其子类对象时,只有当 object.instanceOf(子类X)时,我们才能 子类X x=(子类X)object; 否则就会相应的转换异常

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	











<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

gui的笔记:
	
<=====================================================================================================================================================================>

1.gui中常用的类

	Frame : 老式的窗口创建
	JFrame : 新式的窗口创建
	JLabel : 字段标签
	JTextField : 创建普通文本框
	JPasswordField : 创建密码文本框
	BottonGroup : 用于封装单选钮的
	JRadioButton : 用于创建单选钮的
	ActionListener : 用于按钮监听
	JOptionPane : 用于产生警告提示窗口的  //
	JSplitPane : 用于分割窗口
	JTabbedPane : 一页多个窗口
	WindowListener : 可以监听窗口上的按钮


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

如果关闭窗口:

	new JFrame().dispose();

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

设置JTable表中的某一行为选中状态:
	
	jTable.setRowSelectionInterval(0, 0);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

JSplitPane的使用范例:

	public void patientConsultSplitPane(JFrame jFrame, DifferenceObject object) {
		JPanel primaryJPanel = new JPanel();
		JPanel topJPanel = new JPanel();
		JPanel bottomJPanel = new JPanel();
		JPanel leftJPanel = new JPanel();
		JPanel rightJPanel = new JPanel();

		// -------------------------------
		topJPanelContext(topJPanel, object);
		leftJPanelContext(leftJPanel, object);

		// ----------------------------------

		JSplitPane jSplitPaneVertical = new JSplitPane(
				JSplitPane.VERTICAL_SPLIT, topJPanel, bottomJPanel);
		JSplitPane jSplitPaneHorezontal = new JSplitPane(
				JSplitPane.HORIZONTAL_SPLIT, leftJPanel, rightJPanel);

		leftJPanel.setPreferredSize(new Dimension(ConstantUtils.WIDTH / 4,
				ConstantUtils.HEIGHT - ConstantUtils.HEIGHT / 8));
		rightJPanel.setPreferredSize(new Dimension(ConstantUtils.WIDTH
				- ConstantUtils.WIDTH / 4, ConstantUtils.HEIGHT
				- ConstantUtils.HEIGHT / 8));

		topJPanel.setPreferredSize(new Dimension(ConstantUtils.WIDTH,
				ConstantUtils.HEIGHT / 14));
		bottomJPanel.setPreferredSize(new Dimension(ConstantUtils.WIDTH,
				ConstantUtils.HEIGHT - ConstantUtils.HEIGHT / 8));

		patientConsultTabbedPane(rightJPanel, object);
		primaryJPanel
				.setBounds(0, 0, ConstantUtils.WIDTH, ConstantUtils.HEIGHT);
		bottomJPanel.add(jSplitPaneHorezontal);
		primaryJPanel.add(jSplitPaneVertical);
		jFrame.add(primaryJPanel);
	}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
JTabbedPane的使用范例:
	
	public void patientConsultTabbedPane(JPanel rightJPanel,
			DifferenceObject object) {
		JPanel tabbedPaneJPanel1 = new JPanel();
		JPanel tabbedPaneJPanel2 = new JPanel();
		tabbedPaneJPanel2Contect(tabbedPaneJPanel2,object);
		// --------------------------

		tabbedPaneJPanel1Context(tabbedPaneJPanel1, object);
	

		// --------------------------
		JTabbedPane jTabbelPane = new JTabbedPane(JTabbedPane.TOP,
				JTabbedPane.WRAP_TAB_LAYOUT);

		jTabbelPane.add("初诊登记", tabbedPaneJPanel1);
		jTabbelPane.add("病例管理", tabbedPaneJPanel2);

		rightJPanel.add(jTabbelPane);
		jTabbelPane.setPreferredSize(new Dimension(ConstantUtils.WIDTH
				- ConstantUtils.WIDTH / 4, ConstantUtils.HEIGHT
				- ConstantUtils.HEIGHT / 8));
	}


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2如何为单选钮设置值与提取值

       // 建立一个单选钮
		final JRadioButton jRadioButtonFemale = new JRadioButton("女",true);
		jRadioButtonFemale.setBounds(155, 200, 20, 20);
		buttonGroup.add(jRadioButtonFemale);
		this.add(jRadioButtonFemale);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Student student=new Student();
	if(jRadioButtonFemale.isSelected()){
	student.setGende(jRadioButtonFemale.getText());
		}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
3.如何从表格中取得值与产生警告窗口:

	int j=jTable.getSelectedRowCount();
				int i=jTable.getSelectedRow();
				if(i==-1||j!=1){
				}else{
					int id=Integer.parseInt((String)jTable.getValueAt(i, 0));
					new UpdateData(). updateWindow(id);
				}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

3.产生多个按钮的警告窗口:

    int i= JOptionPane.showConfirmDialog(null, "确定删除吗?");  //注意,它应有返回值

<=====================================================================================================================================================================>

gui中动态显示思想:
	
	如果要在一个JFrame 或 JPanel 中进行动态的显示,则该动态显示的组件必须每次使用的都是同一个组件,且之后都必须接一个 JFrame 或JPanel 的 对象.updateUI() 方法
	
   列如:

	1. dc.jLabelComponent(jPanel21, patient.getName(), 70,70,60,20,null);
------------------------------------------------------------------------------------------
	2.
	private JLabel jLabel;	//该属性是一个成员变量

	public JLabel jLabel(){
		JLabel jLabel=null;
		if(this.jLabel==null){
			this.jLabel=new JLabel();
			jLabel=this.jLabel;
		}else{
			jLabel=this.jLabel;
		}
		return jLabel;
	}
------------------------------------------------------------------------------------------
	3.
          //单列JLabel
	public JLabel jLabelComponent(JPanel jPanel,String name ,int x,int y,int width,int height,String s){
		JLabel jLabel=jLabel();
		jLabel.setText(name);
		System.out.println(name+"="+jLabel);
		jLabel.setBounds(x, y, width, height);
		object.getJlabelMap().put(name, jLabel);
		jPanel.add(jLabel);
		return jLabel;
	}
------------------------------------------------------------------------------------------	

       4.jPanel21.updateUI();

------------------------------------------------------------------------------------------	
       5.JTable要用到model,原理也是这样的

<=====================================================================================================================================================================>



















<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

xml部分:
<=====================================================================================================================================================================>

xml的理解: xml中存储的仅仅是内容,xml它是一种可扩展的语言,即标签可以随意写,而html是一种不可扩展的语言,因为他的标签都是规定好了的 ,当然xml是区分大小写的,xml中的属性值可以用双引号,也可以使用单引号,当然双引号与单引号也可以嵌套使用,当然嵌套必须要合理,即若一个属性的值在外层使用呢双引号,那么内层就要使用单引号, 反之同理.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
文本节点是元素吗?

	文本节点不是元素.
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
DTD与xml的关系:

	其实DTD与xml的关系就像类与对象的关系.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
xml文件的字符编码与xml文件内容的字符编码的异同:

	xml头中的 encoding="utf-8" 是指定该xml文件的内容的字符编码为"utf-8" ,而如何指定该文件的字符编码为utf-8呢 ? 是通过记事本的另存为中字符集为其指定字符编码.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
xml的命名空间:

	xml的命名空间是解决两份xml文件中同名的元素或其他一些同名的东西.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在xml中插入纯文本:

	<![CDATA[要显示出来的纯文本内容]]>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
xml的解析与生成:

	xml解析: 从xml------转换为------>读出来的内容       //  关于xml的解析与生成的使用案例在 常用类 中
	xml生成: 从内容------转换为------>xml

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
xml的解析与生成有哪些方式:

	有 DOM ,SAX,JDOM,DOM4J

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
DOM是如何解析xml文件的:

	DOM解析是将xml文件进行整体解析.即把xml当做一颗完整的树来进行整体解析

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
DOM解析的优缺点:

	DOM解析的优点:效率高.
	DOM解析的缺点:当xml的文件太大是,会造成内存溢出

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
SAX解析:

	SAX解析是将xml进行分步解析,即一个节点一个节点的去读.也就是用回调的方式去解析

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
DOM与DOM4J的区别:

	DOM是基于类编程的,而DOM4J是基于接口编程的


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

xml的模板:

	<?xml version="1.0" encoding="utf-8">

	<!-- 要注释的内容-->

	<root>
		<subNode>
    			...
		</subNode>
                <subNode>
			...
		</subNode>
		    .
		    .
		    .
	</root>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于Windows中的路径问题:

	1.若该路径是在系统中以某种方式获取的.若要把他替换为 "/" ,要用 path = path.replace("\\\\", "/");
	2.若是以参数的方式传过来的.而也要把它替换为"/",就要用 path = path.replace("\\", "/");
	
	3.为了防止替换失败.介意 将两个方法一起使用.如下
	
	 public static String change(String path){
    	path = path.replace("\\\\", "/");
    	path = path.replace("\\", "/");
    	return path; //Java中4个反斜杠表示一个反斜杠
    }
	
	这样用是为了兼容 Linux系统.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于将某一串字符串存储到文件中的方法:

	Long dateFile = new Date().getTime();

	/**将日期存储到文件中*/
	public void getDateFromFile(Long dateFile) throws Exception{
		File file = new File("./newDate.txt");
		String dateString = dateFile.toString();
		DataOutputStream dos=new DataOutputStream(new FileOutputStream(file));
		dos.writeUTF(dateString);
	}
	
	/**从文件中读取内容*/
	public Long setDateToFile() throws Exception{
		File file = new File("./newDate.txt");
		DataInputStream dis = new DataInputStream(new FileInputStream(file));
		String dateString=dis.readUTF();
		Long dateLong = new Long(dateString);
		return dateLong;
	}
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何将java.sql.Clob类转换为String

	案例一:
	
		String s = clob.getSubString(1, (int) clob.length());
		
	案例二:
	
		Reader inStreamDoc = clob.getCharacterStream();   
	    char[] tempDoc = new char[(int) clob.length()];   
	    inStreamDoc.read(tempDoc);   
	    inStreamDoc.close();   
	    String s = new String(tempDoc);
		
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何将reader 字符流转换为字符串

	Reader inStreamDoc = clob.getCharacterStream();   
	char[] tempDoc = new char[(int) clob.length()];   
	inStreamDoc.read(tempDoc);   
	inStreamDoc.close();   
	String s = new String(tempDoc);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------


































<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

WEB部分:
<=====================================================================================================================================================================>

http协议:
	
	超文本传输协议,具有无状态性.且永远都是请求与相应的模式,

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Get 请求与响应方式:

	request:有请求头,请求行 : 数据是在请求行里带到服务器端的,

	response:有响应头,响应行 ,响应正文:指的就是html中的内容

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Post 请求与响应方式:

	request:请求头,请求行 ,请求正文:数据是在请求正文中带到服务器端的.

	response:有响应头:响应行,响应正文:指的就是html中的内容


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Tomcat 的启动:

	Tomcat想要启动,应在环境变量中配置JAVA-HOME;java_home中写的是jdk的安装路径

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何修改Tomcat的端口:

	在/tomcat/conf/server/中<connector port="8080" http...>中修改port.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在Tomact服务器中创建一个工程:

	在webapps目录下建一个工程名为 test 目录.在那个test下创建一个 WEB-INF 目录,在WEN-ING下创建一个classes与一个lib目录,再创建一个web.xml文件.然后将在myEclipse中的	class文件目录复制到 classes目录下.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查看本机的端口号:

	打开命令串口.在该窗口下输入 netstat-ano 后按下enter键即可.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在myeclipse中打开Navigator
	
	点击window , show/view ,other,Navigator 即可.
		
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何将servlet中的内容输入到浏览器页面中:

	response.getWriter.write("<html><head><title>my first servlet</title></head><body>welcome you! servlet</body><html>");

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对web.xml中的几个标签的理解:
	<servlet>	//对servlet的配置
		<servlet-name>First</servlet-name>  //servlet的类名
		<servlet-class>cn.scxh.servlet.First</servlet-class>  servlet类的 权限定名
	</servlet>

	<servlet-mapping> 对servlet映射的配置
		<servlet-name>First</servlet-name> //servlet的类名
		<url-pattern>/First</url-pattern>  //浏览器要访问的路劲名
	</servlet-mapping>
	<welcome-file-list> //浏览器访问一个程序的入口
		<welcome-file>index.jsp</welcome-file>  //web_inf下的jsp
	</welcome-file-list>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对form表单中action属性是怎样填的:
	
	form表单中的action写的是servlet的类名

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Tomcat中的全局包与局部包的关系:

	Tomcat中自带的包是全局包,我自己导进去到lib目录下的包是局部包.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
纯手写的工程与用myEclipse写的工程的区别:

	用手写的工程从客户端转到服务端时,路径名不写 工程名 ,而用Myeclipse写的工程这 必须写.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
<textarea>标签如何返回值:

	<textarea>标签与其他的标签有一定不一样,他的返回值是些在标签中,而不是写在属性上.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
使用jsp与html区别:

	当我们要在一个表单上回显值时,我们只能使用jsp,不能使用html,因为html中不能使用 EL 表达式.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于路径问题:

	1. 斜杠(/) ,如果该路径是转发到 java 工程中 ,那么 斜杠(/)就表示这个工程的当前路径 (即 你的工程所在文件目录). 如果是该路径是转发到jsp/html页面,而该工程最终是要部		署到服务器中,那么这个斜杠(/)就代表该服务器的webapps目录(这是指Tomcat服务器),

	2.点斜杠(./),当一个目录前加了 点斜杠(./)或者 不加 点斜杠(./),这都代表当前路径,(即你当前文件所在的目录) 例如:有一个绝对路径是 " D:\java\javaTools\myeclipse		\myeclipse-8.5.0\workspace8.5\MyFirstProject\WebRoot\index.jsp ".而你当前所写的文件是index.jsp,那么你的 点斜杠(./) 就代表当前目录webRoot .

	3.点点斜杠(../)与点点斜杠再点点斜杠(../../): 点点斜杠(../)表你的当前文件所在的目录的上一级目录,而点点斜杠再点点斜杠(../../)表示你的当前文件所在的目录的上一级目		录的上一级目录.

	4.当我们访问一个页面是抛出了404这个异常是,这代表他没有找到对应的文件,同时他会显示出他找的路劲,如果这个请求是表单路劲,那我们就要 结合我们所配的 web.xml 文件中的
	<url-pattern> 路劲去修改.

	5.为什么我们在表单中向某一个工程中提交表单时,我们要用于 斜杠(/)与工程名 ,而我们在工程中向某一页面转发时,却不写 斜杠(/) 与工程名,我们都知道 斜杠(/)表示当前文件		或当前文件夹所在的目录,当我们用表单提交是,我们就要用 斜杠(/) 得到服务器中的用于存放工程的目录(即工程所在的目录)(tomcat的当前工程所在的目录是webapps),而工程名与		servlet名表示我们要向那个工程的那个servlet转发,而当我们在工程中向某一页面转发时,因为该页面就在工程中,所以我们不用 斜杠(/),只需要用 点斜杠(./)或不写点斜杠(./)得        	到当前目录即可.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
404与500错误:

	404表示客户端的错误
	500表示服务端的错误

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于css与js的编码问题:
	一般css与js的编码用jsp与html去控制.如果是html.我们用用这段代码去控制:<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">; 如果是jsp我们直接在头	中控制即可.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
乱码问题:

	request 对于post中的请求乱码的解决范式: req.setCharacterEncoding("UTF-8");

	response 对于post中的响应乱码的解决范式: resp.setContentType("text/html;charset=utf-8");

	response 对于get中的响应乱码的解决范式:response.setCharacterEncoding("UTF-8");	

	request 对于get中的请求乱码的解决方式:

				String gender=req.getParameter("gender");
				byte[] buf = gender.getBytes("ISO8859-1");
				gender = new String(buf,"UTF-8");

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何生成class文件:

	当我们把自己bin目录下的class文件删除掉了后,我们如何再将其生成,(注意,这里删除的是class文件,而不是原代码),打开myeclipse中点击project , clean 后将会自动生成

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在servlet中关于servletContext的使用:

	servletContext在jsp中的九个内置对象中叫做application,但是在servlet由于没有直接的application对象.只能通过 ' servletContext application=this.getServletContext() 	'方法得到


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
session与cookie的区别:
	1.保存内容的地方不一样,cookie保存在客户端,而session保存在服务端
	2.session是安全的,而cookie是不安全的,
	3.cookie有大小的限制.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何销毁session对象中存储的内容.

	销毁session中存储的内容一般用invalidate()方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
servlet的生命周期:

	实例化:servlet容器创建servlet的实例
	初始化:该容器调用init()方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
HTTP1.0与HTTP1.1的区别:

	HTTP1.0是短连接,性能低,而HTTP1.1是长连接,性能较高

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
servlet在tomcat中是以什么形式存在:

	servlet在tomcat服务器中是以单例的形式存在,因此不能定义成员变量,因为存在线程安全问题

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
过滤器的作用:

	1.用于管理是否登录
	2.用于统一编码问题
	3.对非法文字进行过滤

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
修改tomcat的编码

	在TOMCAT中的server.xml中的

	<Connector中添加两个设置useBodyEncodingForURI="true" //设置POST和GET使用相同编码
	URIEncoding="UTF-8" //对URI使用utf-8编码处理?

	<Connector useBodyEncodingForURI="true" URIEncoding="UTF-8" connectionTimeout="20000" maxThreads="150" port="8888" protocol="HTTP/1.1" redirectPort="8443"/>


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
常用的服务器有那些?

	有 tomcat ,WebLogic,websphere

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
jsp与servlet各自的主要作用:

	jsp主要是用于做显示,而servlet主要是用来做逻辑判断

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
用重定向不能办到的事:

	用response.sendRedirect()不能从servlet中将信息带到jsp中,而应该用request.getRequestDispatcher("连接地址url").forward(request,response);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在jsp中用脚本的方式将动态的信息展示在页面中:

	应该使用<%= ... %> 的形式.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于在jsp使用地址的几个注意事项:

	1.在jsp的<head>标签中有一行代码是: <base href="<%=basePath%>"> 他的意思是该页面中的其他所有地址都应该使用根路径的形式(即(/工程名/..))
	2.在jsp中其实每一个跳转到servlet的超链接都对应web.xml文件中的一个servlet配置,只是我习惯只在web.xml只配置一个,而在servlet类中去分支罢了.
	3.在jsp使用<jsp:forward/>标签的正确方式应为: <jsp:forward page="/WEB-INF/jsp/user/login/userLoginUI.jsp"></jsp:forward>,原因是jsp其实也就是一个servlet.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
原生js与jquery如何混用:

	1.原生的js函数中可以直接使用jquery的相关特性.同时jquery中也可直接使用js的相关特性
	2.jquery中可以直接调用原生js函数,但是在原生的js函数中去不可以直接调用在jquery中定义的函数

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何使用json传输从数据库中取出来Date()型日期.

	因为json传输date数据时需要判断new Date().getHears(),而从数据库中取出来的Date是没有Hear的,所以将从数据库取出来的date进行如下转换即可:

	java.util.Date birthday=rs.getDate("birthday");
				SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");
				try {
					birthday=sdf.parse(sdf.format(birthday));
				} catch (ParseException e) {
					e.printStackTrace();
				}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
mvc模型:

	m (model)模型 		: javaBean
	v (view) 模型 		: jsp/html
	c (controller)模型	: 控制器(servlet)

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么是javaBean?

	1.属性私有化
	2.提供了set()与get()方法
	3.不能放在裸包中
	4.提供无参数的构造方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
jsp中九大内置对象分别是:

	page,pageContext,request,response,session,application,config,exception,out

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
jsp中九大内置对象与servlet中的内置对象的对应关系:

	jsp的内置对象			servlet中的内置对象

	page				page
	pageContext			没有与之对应的对象
	request				HttpServletRequest
	response			HttpServletResponse
	session 			HttpSession
	application			getServletContext();
	config				servletConfig
	exception			exception
	out				PrintWriter

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何直接访问WEB-INF下的jsp/html

	<servlet>
		<servlet-name></servlet-name>
		<jsp-file></jsp-file>
	</servlet>
	<servlet-mapping>
		<servlet-name></servlet-name>
		<url-pattern></url-pattern>
	
	</servlet-mapping>


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
jsp中有那几个指令:

	page 		<%@ page ..%>
	include		<%@ include ..%>
	taglib 		<%@ taglib ..%>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
<%@ include ..%> 与<jsp :include  ..> 的区别:

	1.<%@ include ..%>是将页面的内容放到一起,最后生成java文件,然后再编译成class文件,而<jsp :include  ..> 是被包含的页面自己生成java和编译成class文件,最后再将结果放		在一起.
	2.<%@ include ..%>如果包含的jsp,包含页面与被包含页面是同一个request对象,而<jsp :include  ..>包含页面与被包含页面不是同一个request对象
	3.<%@ include ..%>不能传参数,而<jsp :include  ..>能够传参数到包含的页面

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
4个属性的范围:

	pageContext : 只能在当前jsp页面使用
	request : 一次请求中使用
	session :一次回话中使用
	application :整个服务器范围内使用

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
两种跳转:

	request.getRequestDispatcher("跳转的页面地址").forward(request, response);  //服务器端跳转,能够保存request里的内容,地址不变

	response.sendRedirect("重定向的页面地址"); //客户端跳转,不能够保存request里的内容,地址要变

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
超链接属于社么跳转?

	属于客户端跳转

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
EL表达式(Expression Language) :

	1.只能只对 ( pageContext , request ,session ,application ) 这四个属性范围使用
	2.在使用EL表达式时,如果没有具体指明查找哪一个域对象,系统就会从小到大依次查找jsp中的四个域对象,一般先找到先用

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
jstl的全称:

	jsp standard taglic library

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
javascript的为代码与jsp中EL表达式的高级用法:

	注: 该方法非常适合用于将jsp中的动态参数传递到jsp中

	<a href="javascript:go('${book.id!=null?book.id!=''?book.id:-1:-1}','${book.bookName!=null?book.bookName!=''?book.bookName:-1:-1}','${book.bookType!=null?	book.bookType!=''?book.bookType:-1:-1}','${book.author!=null?book.author!=''?book.author:-1:-1}')">go</a>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在jsp中进行判断与运算?

	由于在jsp全是标签,不能直接判断与运算,因此在jsp中进行判断与运算要借助EL表达式

	例如: ${i==1}这是判断
	      ${i-1}这是运算

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对 select * from 表名 where .. limit x ,y ;中的 x 与 y的理解

	x:表示从x+1条记录开始
	y:需要显示的记录数

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 如何为select标签设置动态选中:

	注:<option ${classify.classifyName==book.bookType?'selected':''} value="${classify.id}" >${classify.classifyName}</option>在jsp中会报警告Undefined attribute 		name ,这警告我们可以不用去处理.

	<select name="bookType" >
	  	<option>请选择</option>
	  	<c:forEach var="classify" items="${classifyList}">
	  		<option ${classify.classifyName==book.bookType?'selected':''} value="${classify.id}" >${classify.classifyName}</option>
	  	</c:forEach>
	</select>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
普通的表单上传需要的协议:

	enctype="multipart/form-data"

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java中如何判断访问的浏览器类型是IE:

	boolean isIE = (request.getHeader("user-agent").indexOf("MSIE")!=-1);
	
	解析: true表示为IE,false表示为非IE
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------









<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在jsp页面中定义一个变量并进行简单的判断:

	<c:set  var="i" value="1"></c:set>

	${i==1 }

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
一个jquery 对象数组当用 $.each(v,function(j,o){});遍历后 o是什么对象?

	是一个js原生对象

  范例:

	var v=$("input[name='gender']");
		    	$.each(v,function(j,o){
		    		var v11=$(o).attr("value");
		    		alert(v11);
		    	});

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------


























<=====================================================================================================================================================================>

<=====================================================================================================================================================================>
用beanUtil框架收集参数的范例:

//使用该框架需要导入commons-beanutils-1.8.0.jar和commons-logging.jar两个包才能使用

                        Customer customer=new Customer();
			Enumeration<String> enums=request.getParameterNames();
			while(enums.hasMoreElements()){
				String key=enums.nextElement();
				String[] values=request.getParameterValues(key);
				try {
					BeanUtils.setProperty(customer, key, values);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}//while循环

<--------------------------------------------------------------------------------------------------------------------------------------------------------------------->

BeanUtils框架使用范例:

//从表单中获得的参数名字必须与javaBean中属性名一一向同,当然,javabean中属性名可以多于从表单中获得的参数名;

Enumeration<String> enums=request.getParameterNames();
		Business business=new Business();
		while(enums.hasMoreElements()){
			String key=enums.nextElement();
			String[] values=request.getParameterValues(key);
			try {
				BeanUtils.setProperty(business, key, values);
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				e.printStackTrace();
			}
		}

<=====================================================================================================================================================================>

如何对日期进行加减:

                                Calendar c = Calendar.getInstance();
				c.add(Calendar.DATE,-1);
				//取得昨日流量
				Flow flow = bbsService.findFlowByDate(c.getTime());

<=====================================================================================================================================================================>
针对带有较大跨度的日期的相减的 大约 计算方法:

	Calendar calendar = Calendar.getInstance();
	calendar.set(2020,9,15); //切记这里的月份是从0开始的,及0表示1月
	Date date1 = calendar.getTime();
	SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); //这里只有是为了能够输出来看看
	String dateStr1 = format.format(date1);  //这里只有是为了能够输出来看看
	System.out.println(dateStr1);
	long l1 = date1.getTime();

	Calendar calendar2 = Calendar.getInstance();
	calendar2.setTime(new Date());  //当前的日期
	Date date2 = calendar2.getTime();
	String dateStr2 = format.format(date2); //这里只有是为了能够输出来看看
	System.out.println(dateStr2);
	long l2 = date2.getTime();
	long l3 = l1-l2;
	long allDay = l3/(24*60*60*1000); //这里只能先得到天数,在用天数去计算年,月,日,不能够" l3/(24*60*60*1000*365) "
	long year = allDay/365l;
	long remainMonthDay= allDay%365l; //得到年后,剩余的天数
	long month = remainMonthDay/30l;
	long day = remainMonthDay%30l; //得到月后,剩余的天数
	
	System.out.println(year);
	System.out.println(month);
	System.out.println(day);
	
	//从上文中我们可以看出calendar2是当前的日期,
	System.out.println(calendar2.get(Calendar.YEAR)); //得到当前日期的year
	System.out.println(calendar2.get(Calendar.MONTH)+1); //得到当前日期的month,(由于在calendar这个类中将month的起始月份表示为0,所有输出的结果要加1)
	System.out.println(calendar2.get(Calendar.DAY_OF_MONTH)); //这是得到这个月中的天
	System.out.println(calendar2.get(Calendar.DAY_OF_WEEK)); //这是得到一个星期中的周几

<=====================================================================================================================================================================>
针对带有较大跨度的日期的相减的 精确 计算方法:

	package cn.wulin.controller.springMVC;

	import java.util.Date;
	import java.text.DateFormat;
	import java.text.ParseException;
	import java.text.SimpleDateFormat;
	import java.util.Calendar;

	public class MyCalendar {
		Calendar datebegin;
		Calendar dateend;
		DateFormat df;

		public Calendar getDatebegin() {
			return datebegin;
		}

		public void setDatebegin(Calendar datebegin) {
			this.datebegin = datebegin;
		}

		public Calendar getDateend() {
			return dateend;
		}

		public void setDateend(Calendar dateend) {
			this.dateend = dateend;
		}

		public DateFormat getDf() {
			return df;
		}

		public void setDf(DateFormat df) {
			this.df = df;
		}

		public MyCalendar() {
			df = new SimpleDateFormat("yyyy/MM/dd");
			datebegin = Calendar.getInstance();
			dateend = Calendar.getInstance();

		}

		public MyCalendar(String begin, String end) throws ParseException {
			df = new java.text.SimpleDateFormat("yyyy/MM/dd");
			datebegin = Calendar.getInstance();
			dateend = Calendar.getInstance();
			datebegin.setTime(df.parse(begin));
			dateend.setTime(df.parse(end));

		}

		/**
		 * 当前日比较
		 * 
		 * @return
		 */
		private boolean compareTo() {
			return datebegin.get(Calendar.DAY_OF_MONTH) > dateend
					.get(Calendar.DAY_OF_MONTH);
		}

		private int CalculatorYear() {
			int year1 = datebegin.get(Calendar.YEAR);
			int year2 = dateend.get(Calendar.YEAR);
			int month1 = datebegin.get(Calendar.MONTH);
			int month2 = dateend.get(Calendar.MONTH);
			int year = year2 - year1;
			if (compareTo()) // 计算天时向月借了一个月
				month2 -= 1;
			if (month1 > month2)
				year -= 1;
			return year;
		}

		private int CalculatorMonth() {

			int month1 = datebegin.get(Calendar.MONTH);
			int month2 = dateend.get(Calendar.MONTH);
			int month = 0;
			if (compareTo()) // 计算天时向月借了一个月
				month2 -= 1;
			if (month2 >= month1)
				month = month2 - month1;
			else if (month2 < month1) // 借一整年
				month = 12 + month2 - month1;
			return month;

		}

		private int CalculatorDay() {

			int day11 = datebegin.get(Calendar.DAY_OF_MONTH);
			int day21 = dateend.get(Calendar.DAY_OF_MONTH);

			if (day21 >= day11) {
				return day21 - day11;
			} else {// 借一整月
				Calendar cal = Calendar.getInstance();
				cal.setTime(dateend.getTime());
				cal.set(Calendar.DAY_OF_MONTH, 1);
				cal.add(dateend.DAY_OF_MONTH, -1);
				return cal.getActualMaximum(Calendar.DATE) + day21 - day11;
			}
		}

		/**
		 * 返回两个时间相隔的多少年
		 * 
		 * @return
		 */
		public int getYear() {
			return CalculatorYear() > 0 ? CalculatorYear() : 0;
		}

		/**
		 * 返回除去整数年后的月数
		 * 
		 * @return
		 */
		public int getMonth() {
			int month = CalculatorMonth() % 12;
			return (month > 0 ? month : 0);
		}

		/**
		 * 返回除去整月后的天数
		 * 
		 * @return
		 */
		public int getDay() {
			int day = CalculatorDay();
			return day;
		}

		/**
		 * 返回现个日期间相差的年月天以@分隔
		 * 
		 * @return
		 */
		public String getDate() {
			return getYear() + "@" + getMonth() + "@" + getDay();
		}
	}

<=====================================================================================================================================================================>



对于日期检证，需要使用	

//需要导入包:beanutils包
			
	DateLocaleConverter dlc = new DateLocaleConverter(Locale.CHINA,"yyyy-MM-dd");
	dlc.convert(this.birthday);

<=====================================================================================================================================================================>

//注册一个String->java.util.Date转换器
		ConvertUtils.register(
				new DateLocaleConverter(Locale.CHINA,"yyyy-MM-dd"),
				java.util.Date.class);


<=====================================================================================================================================================================>

在servlet中对传过来的参数进行解码

	//该方法主要是真对Get请求
	
	String province = request.getParameter("province");
		byte[] buf = province.getBytes("ISO8859-1");
		province = new String(buf,"UTF-8");

<=====================================================================================================================================================================>

对于 .properties 文件的加载的写法:
	
	//这里的this可以是当前类的类名
	//this.getClass().getClassLoader().getResourceAsStream(" ");这里有getClassLoader()方法,表示去相对路径的根路径去找,即web工程应用路径下
	//this.getClass().getResourceAsStream(" ");这里没有getClassLoader()方法,表示去同一个包下去找
	
	........................................................................................................................................
	
		// 从classpath的根目录中查找a.txt文件
		this.getClass().getClassLoader().getResourceAsStream("a.txt");

		// 从classpath的根目录中查找a.txt文件
		this.getClass().getResourceAsStream("/a.txt");

		// 从当前类所在的包中查找a.txt文件
		this.getClass().getResourceAsStream("a.txt");

	........................................................................................................................................

		InputStream inputStream=this.getClass().getClassLoader().getResourceAsStream("  ");
		Properties props=new Properties();
		props.load(inputStream);
		inputStream.close();
		
	........................................................................................................................................
	案例:
			/**设置数据源*/
			public void getConficMessage(){
				InputStream is = DBUtil.class.getResourceAsStream("/myJdbc.properties");
				Properties p =new Properties();
				try {
					p.load(is);
					String user=p.getProperty("oracle.user");
					String password=p.getProperty("oracle.password");
					String driverName = p.getProperty("oracle.driverName");
					String url = p.getProperty("oracle.url");
					System.out.println(url);
					dataSource = new ComboPooledDataSource();
					dataSource.setUser(user);
					dataSource.setPassword(password);
					dataSource.setJdbcUrl(url);
					dataSource.setDriverClass(driverName);
					dataSource.setInitialPoolSize(3);
					dataSource.setMinPoolSize(1);
					dataSource.setMaxPoolSize(10);
					dataSource.setMaxStatements(50);
					dataSource.setMaxIdleTime(60);
					dataSource.setAcquireIncrement(5);
				} catch (Exception e) {
					e.printStackTrace();
				}finally{
					if(is!=null){
						try {
							is.close();
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
			}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

public class UserDaoImpl {
	private String jdbcUrl;
	private String driverClass;
	private String username;
	private String password;

	// ...

	public UserDaoImpl() {
		// 读取配置文件
		String resource = "jdbc.properties";
		Properties props = loadProperties(resource);

		// 并初始化信息
		jdbcUrl = props.getProperty("jdbcUrl");
		driverClass = props.getProperty("driverClass");
		username = props.getProperty("username");
		password = props.getProperty("password");

		// 显示信息
		printInfo();
	}

	/**
	 * 加载配置文件
	 * 
	 * @param resource
	 * @return
	 */
	private Properties loadProperties(String resource) {
		InputStream inputStream = null;
		try {
			inputStream = getClass().getResourceAsStream(resource);
			Properties props = new Properties();
			props.load(inputStream);
			return props;
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				inputStream.close();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}

	public void printInfo() {
		System.out.println("jdbcUrl  = " + jdbcUrl);
		System.out.println("driverClass = " + driverClass);
		System.out.println("username = " + username);
		System.out.println("password = " + password);
	}


<=====================================================================================================================================================================>

读取磁盘文件的代码:

// 读一个图片文件
		FileInputStream in = new FileInputStream("c:/myPhoto.png");
		byte[] photo = new byte[in.available()];
		in.read(photo);
		in.close();

<=====================================================================================================================================================================>

对 object.getClass();的理解;

	//System.out.println(user3.getNumberSet().iterator().next().getClass());   这句话表示的是:首先得到Set集合,然后对该集合进行迭代,然后得到迭代的值,最后得到该值得类型.

<=====================================================================================================================================================================>

struts2中文件上传的代码:

System.out.println("reg : " + name);
		String dir = ServletActionContext.getServletContext().getRealPath("/upload");
		String ext = photoFileName.substring(photoFileName.lastIndexOf("."));
		long l = System.nanoTime();
		File newFile = new File(dir,l + ext);
		photo.renameTo(newFile);

<=====================================================================================================================================================================>

UUID生成代码:

   UUID.randomUUID().toString()

<=====================================================================================================================================================================>





























javaEE的三大框架
<=====================================================================================================================================================================><=====================================================================================================================================================================>

struts2
<=====================================================================================================================================================================><=====================================================================================================================================================================>
对struts2的认识:

	1.struts2是一个web层的框架
	2.struts2与struts1的关系
		a.struts2是采用webwork技术开发的,所以struts2不是struts1的升级版
	3.web层的框架有:
		struts1,struts2,webwork,jsf,springmvc 等等
	4,简单入门:
		a,导入struts2的包
		b.修改web.xml文件,将该struts2-blank这个工程下的文件复制到web.xml
		c.复制struts2.xml文件从 struts2-blank.war\WEB-INF\classes 该路径下,
		d.修改struts2.xml文件,将除struds这个节点外的其他节点都删除去
		e.部署应用,启动服务器,
		f.输入 http://localhose:8080/工程名/(action.xml中action节点name值)

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
java类中 获取服务器的IP 端口 

	struts2 获取request

	HttpServletRequest requet=ServletActionContext.getRequest();

	requet.getScheme()+"://"+requet.getServerName()+":"+requet.getServerPort()

	(例如)结果为：http://localhost:8080/

	request.getHeader("User-Agent");    //就是取得客户端的系统版本     
	request.getRemoteAddr();    //取得客户端的IP     
	request.getRemoteHost()     //取得客户端的主机名     
	request.getRemotePort();    //取得客户端的端口     
	request.getRemoteUser();    //取得客户端的用户     
	request.getLocalAddr();    //取得服务器IP     
	request.getLocalPort();    //取得服务器端口

	1、JSP中获得当前应用的相对路径和绝对路径
	  根目录所对应的绝对路径:request.getRequestURI()
	  文件的绝对路径 　:application.getRealPath(request.getRequestURI());
	  当前web应用的绝对路径 :application.getRealPath("/");
	   取得请求文件的上层目录:new File(application.getRealPath(request.getRequestURI())).getParent()

	2 Servlet中获得当前应用的相对路径和绝对路径
	  根目录所对应的绝对路径:request.getServletPath();
		文件的绝对路径 :request.getSession().getServletContext().getRealPath(request.getRequestURI())   
	  当前web应用的绝对路径 :servletConfig.getServletContext().getRealPath("/");
	  (ServletContext对象获得几种方式：
	  javax.servlet.http.HttpSession.getServletContext()
	  javax.servlet.jsp.PageContext.getServletContext()
	  javax.servlet.ServletConfig.getServletContext()
	  )

	3.Java类中获得绝对路径
	　　根据java.io.File的Doc文挡，可知: 默认情况下new File("/")代表的目录为：System.getProperty("user.dir")。


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何让struts.xml文件有提示:

	1.找到struts2/lib中的struts2-core-2.2.3.1.jar的文件,打开该文件,
	2.复制struts.xml中出现叹号的HTTP....代码
	3.打开MyEclipse/window/preferences,在里面输入xml,点击xmlcatalog 
	4.点击add按钮,将 key type 更改为 url 
	5.将复制的http...黏贴到key
	6.点击 file system ,选择找到struts2/lib中的struts2-core-2.2.3.1.jar的文件,打开该文件,选择struts-2.0.dtd

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts.xml配置文件如何配置调用方法

	<struts>
	 <constant name="struts.action.extension" value="action" />

    <package name="default" namespace="/" extends="struts-default">

         <action name="parameter_*" class="cn.scxh.action.ActionParameter" method="{1}">
            <result name="success">/index.jsp</result>
        </action>
        
    </package>

    <include file="example.xml"/>

    <!-- Add packages here -->

	</struts>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在Actin类中如何通过驱动模型的方式取值.

	public class ActionParameter extends ActionSupport implements ModelDriven<User>{
	private static final long serialVersionUID = -2181075254943519009L;
	
	User user=new User();
	
	public String getParameter() throws Exception {
		return "success";
	}
	
	public void getValue(){
		System.out.println(user.getId()+" "+user.getName()+" "+user.getPassword()+" "+user.getHappy()+" "+user.getStudent().getId()+" "+user.getCity());
	}

	public User getModel() {
		return user;
	}
}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如果取得web元素,即request,session,application,等几个域对象,

	1.获得struts2包装过得request:

		a.直接使用:ActionContext.getContext().put("user",user);  //这是最常用的.
		b.强转一下:Map<String,Object> request=(Map<String, Object>) ActionContext.getContext().get("request"); request.put("key", value);

	2.获得struts2包装的Session:

		a.ActionContext.getContext().getSession().put(key, value);
	
	3.获得struts2包装的application;

		a.ActionContext.getContext().getApplication().put(key, value);
		
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
ActionContext是否是线程安全的:

	因为ActionContext是一个线程本地化的.所有ActionContext是线程安全的.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.实现requestAware ,SessionAware 接口,

	一下以request为例;

	private Map<String, Object> request=null;

	public void setRequest(Map<String, Object> request) {
		this.request=request;
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.获得原生的request,session,application;	

	HttpServletRequest request=ServletActionContext.getRequest();
	HttpSession session=ServletActionContext.getRequest().getSession();
	ServletContext appliction=ServletActionContext.getRequest().getSession().getServletContext();

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
4.获得原生的request,session,application;几个域对象的方法二,即实现implements ServletRequestAware,SessionAware,ServletContext这几个接口

	private HttpServletRequest request;
	public void setServletRequest(HttpServletRequest request) {
		this.request=request;
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对错误信息的处理:

	1.在继承AcionSupport的方法中使用this.addActionError(anErrorMessage);添加错误信息,在界面上使用<s:actionerror>展示全部的错误消息.
	2.重写父类的validate()方法.在struts.xml中配置<result name="input">返回的页面</result>,将要返回的错误信息写在validate()方法里.用this.addFieldError(fieldName, 		errorMessage);写入错误信息.在界面上使用<s:fielderror></s:fielderror>展示全部的错误信息,用<s:property value="fieldErrors.fieldName"/>展示指定的错误信息.当然也可  	以用打开debug来确定错误信息的具体展示.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何打开debug

	1.在struts.xml加入常量配置:<constant name="struts.devMode" value="true"></constant>
	2.在jsp中使用<s:debug></s:debug>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对struts.xml中的一些常用的配置的说明:

	1.<constant name="struts.action.extension" value="action" />  配置扩展名
	2.<constant name="struts.devMode" value="true"></constant>    当用debug调试时必须有的标签

	3.<package name="default" namespace="/" extends="struts-default">
        
         <action name="fieldObjectAction_*" class="cn.scxh.action.FieldObjectAction" method="{1}">
            <result name="request">/WEB-INF/jsp/fieldObject.jsp</result>
            <result name="input">返回的页面</result>
        </action>
        
    </package>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何清除放在ActionErrors 中的错误信息:

	this.getActionErrors().clear();这个方法是不能清除错误信息的
	this.clearacionErrors();这个方法可以清除错误信息	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
ActionErrors与FieldErrors分别是放在什么中的

	ActionErrors是放在List中的,而FieldErrors是放在LinkedHashMap中的

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts.xml中的模块包含元素:

	<include file=""></include>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
常用的几个跳转方式:

	chain:也是服务端的跳转,即action跳到action
 	<action name="user" class="cn.scxh.action.UserAction" method="add">
            <result type="chain">
            	<param name="actionName">user1</param>
            	<param name="namespace">/u1</param>
            	<param name="method">add1</param>
            </result>
        </action>

	<package name="secondPagckge" namespace="/ul" extends="extends="struts-default"">
    	<action name="user1">
    		<result>error.jsp</result>
    	</action>
    </package>
	
	


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
配置全局异常:

	<package name="default" namespace="/" >
	    <global-results>
	    	<result name="e">/error.jsp</result>
	    </global-results>
	    <global-exception-mappings>
	    	<exception-mapping result="e" exception="java.lang.Exception"></exception-mapping>
	    </global-exception-mappings>
	    
	    
      	  <action name="user" class="cn.scxh.action.UserAction" method="add">
             <result>/index.jsp</result>
      	  </action>
       
   	 </package>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts2的异常处理机制:

	用了struts 2框架,我们可以将ui层的Exception抛出去,但要在struts.xml中进行上述的配置


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查找struts.xml的文档:

	路径是:struts-2.2.3.1-all/struts-2.2.3.1/docs/ww/guides.html

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在struts.xml中进行传参?

	 <result>/...?name=${username}</result> //username对应的Action类必须提供set与get方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
拦截器的使用

	1.自定义拦截器的方式:

		a.实现interceptor接口,重写intercept方法
		b.接承AbstractInterceptor
		c.继承methodFilterInterCeptor类

		注意:实现或重写方法后一定要调用invoke()方法回调

---------------------------------------------------------------------------
struts.xml的配置:    注意:加入拦截器后会把struts默认的拦截器覆盖掉,所有的手动加入默认拦截器

	1.继承methodFilterInterCeptor类的xml配置

			 <interceptors>
        	<interceptor name="test" class="cn.wulin...."></interceptor>
       		 </interceptors>
       		 <action name="user" class="cn.wulin...">
        	<result>/...</result>
        	<interceptor-ref name="text">
        		<param name="includeMethods">add</param>
        		<param name="excludeMethods">add</param>
        	</interceptor-ref>
		<interceptor-ref name="defaultStack"></interceptor-ref>
       		 </action>	

		//注意位置

	----------------------------------------------------------------
	2.实现interceptor接口的xml配置

		 <interceptors>
        	<interceptor name="test" class="cn.wulin...."></interceptor>
        </interceptors>
        <action name="user" class="cn.wulin...">
        	<result>/...</result>
        	<interceptor-ref name="text">
        	</interceptor-ref>
	<interceptor-ref name="defaultStack"></interceptor-ref>
        </action>

	----------------------------------------------------------------
	配置全局拦截器的struts.xml方法:

	<struts>

    <constant name="struts.devMode" value="true" />
    <constant name="struts.action.extension" value="action"></constant>
    
    <package name="struts-myDefaul" extends="struts-default">
    	<interceptors>
    		<interceptor name="myLogin" class="cn.wulin.action.LoginInterceptor"></interceptor>
    		<interceptor-stack name="myInterceptor">
    			<interceptor-ref name="myLogin"></interceptor-ref>
    			<interceptor-ref name="defaultStack"></interceptor-ref>
    		</interceptor-stack>
    	</interceptors>
    	<default-interceptor-ref name="myInterceptor"></default-interceptor-ref>
    	<global-results>
    		 <result name="input">/WEB-INF/jsp/login/login.jsp</result>
    	</global-results>
    </package>

    <package name="firstPackage" namespace="/" extends="struts-myDefaul">
        <action name="login_*" class="cn.wulin.action.LoginAction" method="{1}">
            <result name="success">/WEB-INF/jsp/login/success.jsp</result>
           
            <result name="intercept">/WEB-INF/jsp/login/interceptor.jsp</result>
        </action>
         <action name="various_*" class="cn.wulin.action.variousAction" method="{1}">
            <result name="success">/WEB-INF/jsp/login/success.jsp</result>
            <result name="intercept">/WEB-INF/jsp/login/interceptor.jsp</result>
        </action>
    </package>

</struts>


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于如何在拦截器中如何获取url与参数及调用spring容器管理的Service等的案例:

	public class ChechPrivilegeInterceptor extends AbstractInterceptor{

		public String intercept(ActionInvocation invocation) throws Exception {
			 System.out.println("-----> 之前");
			 
			 //获取参数
			String id = ServletActionContext.getRequest().getParameter("id");
			 System.out.println("=========>>"+id);
			 
				/**
				*获取url
				*/
					// 获取当前用户
				User user = (User) ActionContext.getContext().getSession().get("user");

				// 获取当前访问的URL，并去掉当前应用程序的前缀（也就是 namespaceName + actionName ）
				String namespace = invocation.getProxy().getNamespace();
				String actionName = invocation.getProxy().getActionName();
				String privilegeUrl = null;
				if (namespace.endsWith("/")) {
					privilegeUrl = namespace + actionName;
				} else {
					privilegeUrl = namespace + "/" + actionName;
				}

				// 要去掉开头的'/'
				if (privilegeUrl.startsWith("/")) {
					privilegeUrl = privilegeUrl.substring(1);
				}
			 
			 //调用spring容器管理的service或者javaBean
			 try {
				ServletContext application = ServletActionContext.getServletContext();
				 ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(application);
				 
				 TreeService treeService = (TreeService) ac.getBean("treeServiceImpl");
				 Tree tree = treeService.getById(470l);
			} catch (Exception e) {
				e.printStackTrace();
			}
			 String result = invocation.invoke(); // 放行
			 System.out.println("-----> 之后");
			 return result;
		}
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
拦截器与filter的区别:

	1,filter可以过滤所有的请求,且需要服务器的支持
	2.拦截器只能过滤Action请求,且不需要服务器的支持

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于拦截器invocation对象?

	invocation可以获得我们想要的一些对象.

	例如:获得session: invoction.getInvoctionContext().getSession();
	     获得相应类的字节码对象.invocation.getAction().getClass();

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts2如何使用原始的ajax:

	struts2 中使用原始的ajax是先取得原始的response对象,同时action类中该方法的返回值要设置为null

	例:

		public String ajax() throws Exception {
		HttpServletResponse response=ServletActionContext.getResponse();
		response.getWriter().print("f");//可以返回一个对象
		response.getWriter().write("");//只能返回字符串
		return null;
	}
	
	.........................................................................................
	struts2 中使用原始的ajax是先取得原始的response对象,同时action类中该方法的返回类型要设置为void即可 
	
	public void ajax() throws Exception {
		HttpServletResponse response=ServletActionContext.getResponse();
		response.getWriter().print("f");//可以返回一个对象
		response.getWriter().write("");//只能返回字符串
	}
	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
ognl:

	1.ognlContext:在ognlContext中有一个根对象,ognlContext中可以有许多个对象,但只能有一个根对象
	2.在ognlContext中如果访问的是根对象,就直接访问根对象的属性,如果访问的不是根对象,则就要用"#对象.属性"的形式;
	3.struts2 中ActionContext就是ognlContext,而struts 2的ognlContext的根对象就是valueStack(值栈);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
ognl在struts2中应用

	1.action示例: action示例见常用类中ognlAction

--------------------------------------------------------------------------------
	2.struts.xml 

	<constant name="struts.devMode" value="true"/>
	<constant name="struts.ognl.allowStaticMethodAccess" value="true"/>
    <package name="default" namespace="/" extends="struts-default">
        <action name="ognl" class="cn.scxh.action.OgnlAction">
            <result>/ognl.jsp</result>
        </action>
    </package>

--------------------------------------------------------------------------------	
	3.jsp

	<body>
    	<ul>
    		<li>访问值栈中的属性:<s:property value="username"/></li>
    		<li>访问方法:<s:property value="user.username"/></li>
    		<li>访问普通属性:<s:property value="user.address.city"/></li>
    		<li>访问普通方法:<s:property value="m()"/></li>
    		<hr>
    		<li>访问静态方法:<s:property value="@cn.scxh.action.Test@m()"/></li>
    		<li>访问静态属性:<s:property value="@cn.scxh.action.Test@str"/></li>
    		<li>访问Math类的静态方法:<s:property value="@@max(6,5)"/></li>
    		<hr>
    		<li>访问构造方法:<s:property value="new cn.scxh.action.User('sdfsfd')"/></li>
    		
    		<hr/>
    		<li>访问List:<s:property value="userList"/></li>
    		<li>访问List元素:<s:property value="userList[0].username"/></li>
    		<li>访问List中元素的集合:<s:property value="userList.{password}[0]"/></li>
    		
    		<hr>
    		<li>访问map:<s:property value="map"/></li>
    		<li>访问map的某个元素:<s:property value="map.cc"/>||<s:property value="map['cc']"/>||<s:property value="map[\"cc\"]"/></li>
    		<li>访问map的所有key:<s:property value="map.keys"/></li>
    		<li>访问map的所有value:<s:property value="map.values"/></li>
    		<li>访问容器大小:<s:property value="map.size"/></li>
    		<hr>
    		<li>过滤:<s:property value="userList.{?#this.password=='222'}[0].username"/></li>
    		<li>过滤:<s:property value="userList.{^#this.age>10}.{username}"/></li>
    		<li>过滤:<s:property value="userList.{$#this.age>10}.{username}"/></li>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在struts中一个因为参数类型不对而抛出的一个非常 隐形 (抛出的异常与实践所产生的错误不对应) 的错误:

	问题描述:我在浏览器的地址栏输入 : http://localhost:8888/OAwulinExt/roleAction_list.action?id=wuin    //这里的id为String 类型, 如果 id=123 ,这时这个id的类型可以是数值型 
																									     //也可以是 String 类型
	
	在控制台给我报了如下的错误:
	
	..................................................................................................................................................................
	
			16:58:51,504 ERROR Dispatcher:27 - Could not find action or result
			No result defined for action cn.wulin.oa.view.action.RoleAction and result input
				at com.opensymphony.xwork2.DefaultActionInvocation.executeResult(DefaultActionInvocation.java:364)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:266)
				at com.opensymphony.xwork2.validator.ValidationInterceptor.doIntercept(ValidationInterceptor.java:252)
				at org.apache.struts2.interceptor.validation.AnnotationValidationInterceptor.doIntercept(AnnotationValidationInterceptor.java:68)
				at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor.intercept(ConversionErrorInterceptor.java:122)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)
				at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)
				at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:179)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:94)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:235)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:89)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:130)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:267)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:126)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:138)
				at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:165)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:179)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)
				at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)
				at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:52)
				at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:488)
				at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)
				at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)
				at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)
				at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)
				at org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:198)
				at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
				at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)
				at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)
				at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:240)
				at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:164)
				at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:462)
				at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164)
				at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100)
				at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:562)
				at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)
				at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:395)
				at org.apache.coyote.http11.Http11AprProcessor.process(Http11AprProcessor.java:306)
				at org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler.process(Http11AprProtocol.java:323)
				at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1719)
				at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
				
				at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
				at java.lang.Thread.run(Unknown Source)

	..................................................................................................................................................................
	
	问题产生原因分析:
	
		首先来看我访问的Action :
		
		.......................................................................................................................................................
		
		@Controller
		@Scope("prototype")
		public class RoleAction extends ModelDrivenBaseAction<Role>{  //注意这里我实现了modelDriven接口的,所有会将参数名称与javaBean (Role) 中属性名称相同的值封装到
																	  //JavaBean 的属性中,当然,JavaBean中属性必需要有set与get方法

			public String list() throws Exception {
				PrintWriter print= ServletActionContext.getResponse().getWriter();
				print.write("[{\"id\":4,\"leaf\":false,\"text\":\"部门管理\",\"rootId\":\"2\"}]");
				return null;
			}
			
		}

		.......................................................................................................................................................

		其次来看看我的 JavaBean -->Role
		
		public class Role implements java.io.Serializable {
			private Long id;    //上面请求中的参数id的中的值会自动封装到 该javaBean 的id 中 . id的参数类型为 Long 
			private String name;
			private String description;
			private Set<User> users = new HashSet<User>();

		}

	.......................................................................................................................................................
	阐述问题产生的原因:
	
		这时我们可以看到问题产生的原因了,因为我们传的 id = wulin 这个id的参数为类型为String 类型,而我们的JavaBean中的Id 的类型为 Long 型,所以struts的在封装
		
		参数时报错了,只是struts 所 报错的错误 与 产生错误的原因 不一致.
		
	.......................................................................................................................................................
	解决方案:
	
		将传递的参数与 struts2 要封装的 参数的 类型改为一致即可
	
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------		




















<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
两个Action类之间的调用:
	一个Action类里要调用另一个Action类里的方法或属性,就要在该Action类里面获取另一个类在容器中的对象,然后利用该对象调用另一个类里面的
	方法或属性,并且获取只能在该类里面进行,不能再器父类进行,至于为什么,我现在也不知道.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts2标签的应用:

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts2中的三个域对象:
	ActionContext.getContext().setSession().put("generalUser", user);  	相当于Servlet中session域对象 ,可以包装 对象与集合
	ActionContext.getContext().getValueStack().push(user);  		相当于Servlet中request域对象 ,可以包装 对象与集合
	ActionContext.getContext().put("generalUser", user);  			相当于Servlet中request域对象 ,可以包装 对象与集合



<---------------------------------------------------------------------------------------------------------------------------------------------------------------------




====================================================================
如何在jsp中的<s:..>标签中迭代List<List<Goods>> 两个list嵌套的对象:
	<s:iterator var="goodsList" value="#goodsListList">
  			<tr>
  				<s:iterator value="goodsList">
	  				<td>
	  					<img alt="衣服" src="${pageContext.request.contextPath}${goodsAddress}"><br/>
	  					<s:a>${goodsName}</s:a>
	  				</td>
	  			</s:iterator>
  			</tr>
  			</s:iterator>
			
----------------------------------------------------------------		
<s:hidden name="id"></s:hidden>该标签的使用:
	该标签的value属性我们一般不对其赋予初值,因为赋予初值后.我们在js中获取值时获取不到我们想要的动态绑定的值,获取到的是我们赋予的初值,而在没有赋予初值,又没有动态绑定值时,即value没有值,我们在js中获取到的是 空字符串 (""),而非null值.
		
		
-----------------------------------------------------------------------------------------------------------

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------






















<=====================================================================================================================================================================>
hibernate

<=====================================================================================================================================================================>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
为什么要是使用hibernate?

	让开发者真正做到面向对象

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
orm:

	orm其实就是对JDBC的封装

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
habernate 的基本save()操作:

	@Test
	public void testSave(){
		User user=new User();
		user.setName("哈哈");
		user.setPassword("1234");
		user.setAge(25);
		
		Configuration cfg=new Configuration().configure();
		SessionFactory factory=cfg.buildSessionFactory();
		Session session=factory.openSession();
		session.beginTransaction();
		session.save(user);
		session.getTransaction().commit();
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
当工程上报了一个红叉,但是工程下面的目录却没有错时如何解决?

	查看problems 栏,查看里面的问题,如果添加的包错误,则点击工程打开properties属性,选中相应的错误包,点击remove将其移除

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如果运行工程师出了这个org.hibernate.HibernateException: 'hibernate.dialect' must be set when no Connection avalable错误如何解决?

	那是因为代码Configuration cfg=new Configuration().configure();中你写成了Configuration cfg=new Configuration();
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
为什么要使用ORM框架?

	因为它面向对象

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在面向对象编程中,是有先有类,还是先有表?

	从面向对象的角度来说,要先有类,再有表

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在hibernate中log4j的使用步骤?

	1.slf4j的实现包
	2.添加log4j的包
	3.添加slf4到log4j的转换包
	4.拷贝log4j.properties到src目录下
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查看hibernate自动创建表的语句

	@Test
	public void viewCreateSql(){
		new SchemaExport(new AnnotationConfiguration().configure()).create(true, false);
	}

	// 注意:上面的方法需要Annotation 的架包支持.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何显示sql语句和格式化sql语句

	在hibernate.cfg.xml中用如下标签:

		<property name="show_sql">true</property>
		<property name="format_sql">true</property>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何自动创建表

	<property name="hbm2ddl.auto">update</property>
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
解决Oracle数据库用hibernate在不同用户之间建立相同表名

	在hiberante.properties文件里，设置hibernate.default_schema="用户名"，注：用户名要大写

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
联合主键:

	指的是表中的多个字段共同构成联合主键,当然联合主键必须要有主键所有特性,即唯一性,非空特性等

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何创建一个联合主键:

	将javaBean中需要作为联合主键的字段提出来单独建一个类,并且该类必须序列化其重写equals()与hashCode()方法,以下是主要的javabean与主键javabean和映射文件.xml

	主javaBean;

		public class Person {
		private PersonPk personPK;
		private String gender;
		private Integer age;
		
			//此处省略set与get方法

............................................................
				}

	主键javaBean

		public class PersonPk implements Serializable{

		private Long id;
		private String name;

		//此处省略set和get方法

	重写equals()与hashcode()方法

		@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PersonPk other = (PersonPk) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
				
.................................................................
	
	做映射的xml文件;

		<hibernate-mapping package="cn.wulin.test.domain">
	<class name="Person" table="test_person">
		<composite-id name="pk" class="cn.wulin.test.domain.PersonPk">
			<key-property name="id"></key-property>
			<key-property name="name"></key-property>
		</composite-id>
        <property name="gender" />
        <property name="age" />
	</class>
	</hibernate-mapping>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
为什么要重写equals()方法与HashCode()方法?

	重写equals()方法是为了保证唯一性.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
用hibernate如何做一对一的映射:

	例如:学生(Student) 与 身份证号(CardNumber )的一对一映射

	Student.xml中的关键代码 : <many-to-one name="cardNumber" class="cn.wulin.test.domain.CardNumber" unique="true" column="cordNumberId"></many-to-one> //外键在这一方.

	CardNumber.xml中的关键代码:  <one-to-one name="student" class="cn.wulin.test.domain.Student" property-ref="cardNumber"></one-to-one>  //如果是单选关联是,这方可以不写,
																																		  //但有外键的一方一定要写.

	学生的javaBean;

	private Long id;
	private String username;
	private String gender;
	private CardNumber cardNumber;
	//此处省略set与get方法

``````````````````````````````````````````````

	身份证号的javaBean

	private Long id;
	private String studentCard;
	private Student studnet;

...............................................................

	Student.xml:

	<hibernate-mapping package="cn.wulin.test.domain">
	<class name="Student" table="test_student">
		<id name="id">
			<generator class="native"/>
		</id>
        <property name="username" />
        <property name="gender" />
        <!-- cardNumber,本类与CardNumber类是多对一的关系 -->
        <many-to-one name="cardNumber" class="cn.wulin.test.domain.CardNumber" unique="true" column="cordNumberId"></many-to-one>
	</class>
	</hibernate-mapping>
	
```````````````````````````````````````````````````

	CardNumber.xml:

	<hibernate-mapping package="cn.wulin.test.domain">
	<class name="CardNumber" table="test_cardNumber">
		<id name="id">
			<generator class="native"/>
		</id>
        <property name="studentCard" />
        <!-- student,本类与Student类是多对一的关系 -->
        <one-to-one name="student" class="cn.wulin.test.domain.Student" property-ref="cardNumber"></one-to-one>
	</class>
	</hibernate-mapping>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
用hibernate如何做多对一与一对多的映射:

	例如:用户(User) 与 部门(Department)做多对一与一对多的映射:

	User.xml中的关键代码 (多对一): 
	<!-- department属性 , 本类与Department的多对一 -->
		<many-to-one name="department" class="Department" column="departmentId"></many-to-one>

	Department.xml中的关键代码(一对多):
	<!-- users属性 , 本类与User的一对多 -->
		<set name="users">
			<key column="departmentId"></key>
			<one-to-many class="User"/>
		</set>
		
	``````````````````````````````````````````````

	User的javaBean;

	private Long id;
	private Department department;
	private Set<Role> roles = new HashSet<Role>();

	private String loginName; // 登录名
	private String password; // 密码
	private String name; // 真实姓名
	private String gender; // 性别
	private String phoneNumber; // 电话号码
	private String email; // 电子邮件
	private String description; // 说明
	//此处省略set与get方法

	``````````````````````````````````````````````

	Department的javaBean

	private Long id;
	private Set<User> users = new HashSet<User>();
	private Department parent;
	private Set<Department> children = new HashSet<Department>();

	private String name;
	private String description;

	...............................................................

	User.xml:

	<hibernate-mapping package="cn.wulin.oa.domain">
		<class name="Department" table="wulin_department">
			<id name="id">
				<generator class="native"/>
			</id>
			<property name="name"/>
			<property name="description"/>
			
			<!-- users属性 , 本类与User的一对多 -->
			<set name="users">
				<key column="departmentId"></key>
				<one-to-many class="User"/>
			</set>
			
			<!-- parent属性 , 本类与Department的多对一 -->
			<many-to-one name="parent" class="Department" column="parentId"></many-to-one>
			
			<!-- children属性 , 本类与Department的一对多 -->
			<set name="children">
				<key column="parentId"></key>
				<one-to-many class="Department"/>
			</set>
		</class>
	</hibernate-mapping>
	
```````````````````````````````````````````````````

	Department.xml:
	
		<hibernate-mapping package="cn.wulin.oa.domain">
			<class name="User" table="wulin_user">
				<id name="id">
					<generator class="native"/>
				</id>
				<property name="loginName"/>
				<property name="password"/>
				<property name="name"/>
				<property name="gender"/>
				<property name="phoneNumber"/>
				<property name="email"/>
				<property name="description"/>
				
				<!-- department属性 , 本类与Department的多对一 -->
				<many-to-one name="department" class="Department" column="departmentId"></many-to-one>
				
				<!-- roles属性 , 本类与Role的多对多 -->
				<set name="roles" table="wulin_user_role">
					<key column="userId"></key>
					<many-to-many class="Role" column="roleId"></many-to-many>
				</set>
			</class>
		</hibernate-mapping>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
用hibernate如何做多对多的映射:

	例如:用户(User) 与 岗位(Role)做多对多的映射:

	User.xml中的关键代码 (多对一): 
	<!-- roles属性 , 本类与Role的多对多 -->
		<set name="roles" table="wulin_user_role">
			<key column="userId"></key>
			<many-to-many class="Role" column="roleId"></many-to-many>
		</set>

	Role.xml中的关键代码(一对多):
	<!-- users属性 , 本类与User的多对多-->
		<set name="users" table="wulin_user_role">
			<key column="roleId"></key>
			<many-to-many class="User" column="userId"></many-to-many>
		</set>
		
	``````````````````````````````````````````````

	User的javaBean;

	private Long id;
	private Department department;
	private Set<Role> roles = new HashSet<Role>();

	private String loginName; // 登录名
	private String password; // 密码
	private String name; // 真实姓名
	private String gender; // 性别
	private String phoneNumber; // 电话号码
	private String email; // 电子邮件
	private String description; // 说明
	//此处省略set与get方法

	``````````````````````````````````````````````

	Role的javaBean

	private Long id;
	private String name;
	private String description;
	private Set<User> users = new HashSet<User>();

	...............................................................

	User.xml:

	<hibernate-mapping package="cn.wulin.oa.domain">
		<class name="Department" table="wulin_department">
			<id name="id">
				<generator class="native"/>
			</id>
			<property name="name"/>
			<property name="description"/>
			
			<!-- users属性 , 本类与User的一对多 -->
			<set name="users">
				<key column="departmentId"></key>
				<one-to-many class="User"/>
			</set>
			
			<!-- parent属性 , 本类与Department的多对一 -->
			<many-to-one name="parent" class="Department" column="parentId"></many-to-one>
			
			<!-- children属性 , 本类与Department的一对多 -->
			<set name="children">
				<key column="parentId"></key>
				<one-to-many class="Department"/>
			</set>
		</class>
	</hibernate-mapping>
	
```````````````````````````````````````````````````

	Role.xml:
	
		<hibernate-mapping package="cn.wulin.oa.domain">
			<class name="Role" table="wulin_role">
				<id name="id">
					<generator class="native"/>
				</id>
				<property name="name"/>
				<property name="description"/>
				
				<!-- users属性 , 本类与User的多对多-->
				<set name="users" table="wulin_user_role">
					<key column="roleId"></key>
					<many-to-many class="User" column="userId"></many-to-many>
				</set>
				
			</class>
		</hibernate-mapping>





<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
SessionFactory是提供Session的.该Session里面用于Connection

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
openSession与getCurentSession的区别?

	a.openSession()永远都是打开一个新的Session,而getCurrentSession()首先是去内存中找,如果没有Session.就打开一个Session,否则就使用本地化线程安全的Session
		*特别提醒:使用 getCurrentSession()得到Session的条件是在hibernate.cfg.xml中配置<property name="current_session_context_class">thread</property>

	b.openSession()打开的Session需要我们在用完后手动关闭,而getCurrentSession在事务结束后就会自动关闭.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么时候我们需要使用同一个Session

	当我们需要使用事务提交的时候我们需要使用同一个Session.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
几个常用的方法:

	save();
	update();一般用hql语句
	delete();
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
get()方法与load()方法的区别:

	1.get()会发出sql语句,load()不会发出sql语句,但load()在使用对象的时候会发出sql语句,
	2.get()方法的返回值是一个实际的对象.而load()方法返回的是一个代理对象.
	3.get()方法不会延迟加载,而load方法会使用呢延迟加载
	4.get()方法如果没有查询到数据,会返回一个null,而load()方法会则抛出一个异常.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在Hibernate的 事务之外  使用懒加载的的东西会报如下的错误

	 ERROR LazyInitializationException:42 - failed to lazily initialize a collection of role: cn.wulin.oa.domain.Tree.children, no session or session was closed
	 
	 解决办法:
	 
		1,在事务之内使用懒加载的东西
		2,在Hibernate的映射配置文件中将lazy的值改为false

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
opensession与getCurrentSession的区别:

	1.openSession每次都打开一个新的Session,而getCurrentSession则是先查看内存中是否有Session对象,如果有则使用内存中的,否则创建一个Session

	2.openSession会自动关闭,而getCurrentSession则需要手动关闭.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么是延迟加载?

	在使用的过程中发出查询语句时,有利于提高性能.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
hibernate中的三种状态?

	*注意:以上三种状态都是针对对象来说的.

					数据库		session			内存
		
	transient(瞬时状态)		无		无			有

	persist(持久化状态)		有		有			有

	detached(脱管状态)		有		无			有

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Session中其他几个常用的几个方法

	session.clear(): 清除Session对象
	session.evict(对象x): 清除session中的对象x
	session.flush().将session中更新的对象持久化到数据库中去,当调用commit()方法时.session会自动调用flush()方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在使用hibernate时,如果抛出如下的异常时如何解决?

	org.hibernate.HibernateException: Unable to instantiate default tuplizer [org.hibernate.tuple.entity.PojoEntityTuplizer]
	Caused by: java.lang.reflect.InvocationTargetExceptio	
	Caused by: org.hibernate.PropertyNotFoundException: Could not find a getter for student1 in class cn.wulin.test.domain.CardNumber
	
		该异常是指我的javaBean的属性字段与对应的 ...hbm.xml 的对应的name的值不一样,例如:

	在javaBean中

		private Student student;
				~~~~~~~~

	在 ..hbm.xml中

		 <one-to-one name="student1" class="cn.wulin.test.domain.Student" property-ref="cardNumber"></one-to-one>
			     ~~~~~~~~~~~~~~~
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
使用Iterator 进行查询的示例:

	session.beginTransaction();
		Iterator<User > iteratorUser=session.createQuery("from User").iterate();
		session.getTransaction().commit();
		while(iteratorUser.hasNext()){
			User user=iteratorUser.next();
			System.out.println(user.getUsername());
		}
		session.close();

	*注意:session在这里一定要在使用之后关闭,所以我们一般不用这种方式进行查询,这种查询又叫做N+1查询,具体的理由 在测试是 查看他 输出sql语句就知道了.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何返回一些对象中的一些属性?\

	*特别注意:这里的属性字段必须要大于等于2

	session.beginTransaction();
		List<Object[]> studentListArray=session.createQuery("select s.id,s.username,s.gender from Student s").list();
		session.getTransaction().commit();
		session.close();
		for (Object[] objects : studentListArray) {
			System.out.println(objects[0]+" "+objects[1]+" "+objects[2]);
		}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何使用占位符查询:

	session.beginTransaction();
		List<Student> userList=session.createQuery("from Student s where id=:id and username=:username")
		.setLong("id", 1l)
		.setString("username","haha")
		.list();
		session.getTransaction().commit();
		session.close();

	*特别提醒:使用占位符查询非常适合用于多条件查询

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
一些可能会用到的hql语句.

...............................................	
隐似连接的hql语句.

	1.createQuery("FROM Goods d WHERE d.parent IS NULL").list():List<Goods>

	2.createQuery("FROM Department d WHERE d.parent.id=?").list():List<Department>

	3.createQuery("FROM User u WHERE u.username=? AND u.password=?").list():List<User>;

	4.createQuery("select max(g.id) FROM Goods g").list():List<Long>;

	5.createQuery("from Customer").list():List<Customer>;

	6.createQuery("select id,name from Customer").list():List<Object[]>;

	7.createQuery("from Book b where b.type.name= '00' ").list():List<Object[]>;

	8.createQuery("select new Custormer (id,name) from Customer").list():List<Customer>;  //必须要为Customer提供Custormer (id,name)这样的一个构造方法

	9.createQuery("from Customer where name like 'n%' ").list():List<Customer>;

	10.createQuery("SELECT MAX(f.position) FROM Forum f").list():List<Customer>;

...............................................		
显示连接查询的hql语句

	1.createQuery("from Order o,Customer c where o.customer.id = c.id ").list():List<Object[]>; //这种查询可以代替join查询

	2.其他的join查询 见书上


...............................................	
用于hql语句进行update(更新) 与 delete(删除) :

	update: session().createQuery(" update 类名 as 别名x set x.属性名 = ?").set应用类型(" 第几个问号 ? ", 引用变量).executeUpdate();
	
	对应删除的话,我也不知道是不是像上面那样写.但好像是可以用语句的方式写的

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对1+N的解决方案:

	自己写hql语句去查询

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
list与iterater的区别:

	1.list会把对象查出来,而iterater则会先查出id,用的的时候才去查出对象

	2.list不会去用session级缓存,他只会放到缓存中,而iterater会用到缓存

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
缓存

	a.session级缓存为一级缓存
	b.SessionFactory为二级缓存.

	c.如何使用二级缓存请见书上的 512 页,如何使用 查询缓存请书上的 查询缓存

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
hibernate中锁的机制:

	悲观锁: 
		使用方式:Customer customer=( Customer ) session.load( Customer.class,1, LockMode.UPGRADE );

	乐观锁:

		使用方式:在 xx.	hbm.xml 的配置文件中配置 <version name="version"></version> ,当然在对应的javaBean中要提供对应的属性字段,并提供set与get方法
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------








<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
hibernate中表的设计思想:
	hebernate中表的设计是面向对象的设计思想,不在是关系型表的设计思想.因此数据库中表与表的关联在hibernate设计中不在是用外键,而是用实体与实体的关联(当然,数据库中的表		与表的关联用的还是外键) ,即在javaBean中用的是相互间对象与对象的嵌套.因此我们在javabean看不到外键字段.
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
不同的版本的hibernate的配置文件中使用<property name="hbm2ddl.auto">update</property>这个语句有什么区别?

	hibernate3.3版本在使用这个语句我不知道为什么不起作用,但使用hibernate3.6版本有是可以的,这里我说的版本是jar包的版本,而不是hibernate配置文件的版本.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
几条常用的hql查询语句:
	查询最大值:return (List<Long>) getSession().createQuery("select max(g.id) FROM Goods g").list();   List<Long>最好不要是自己定义的引用类型,否则可能会抛出一些不
					可以预测的异常.其他几个分组函数同理类推.

	得到最顶级父亲:	return getSession().createQuery(//
				"FROM Goods d WHERE d.parent IS NULL")//
				.list();

	得到下一级孩子:return getSession().createQuery(//
				"FROM Department d WHERE d.parent.id=?")//
				.setParameter(0, parentId)//
				.list();

	查询名字与密码:return (User) getSession().createQuery(//
				"FROM User u WHERE u.username=? AND u.password=?")//
				.setParameter(0, username)//
				.setParameter(1, password)
				.uniqueResult();
	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------




















<=====================================================================================================================================================================>

spring2.5
<=====================================================================================================================================================================>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring的入门:

	导包:   1.spring.jar
		2.commons-logging.jar		
		3.log4j-1.2.15.jar

..........................................
ApplicationContext.xml的配置

   <?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd">

	<bean id="mySqlDao" class="cn.wulin.dao.impl.MySqlDaoImpl"></bean>
	<bean id="oracleDao" class="cn.wulin.dao.impl.OracleDaoImpl"></bean>
	<bean id="springService" class="cn.wulin.service.impl.SpringServiceImpl">
		<property name="databaseDao" ref="oracleDao"></property>
	</bean>
	</beans>

....................................................
测试类的关键代码

	@Test
	public void testSpringService(){
		ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml");
		SpringService service=(SpringService) ac.getBean("springService");
		service.save();
		
	}

	//详细的使用方式见 常用类中的 spring_first 工程

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
创建实例的方式有哪些?

	new ,反射,克隆,反序列化

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么叫做IOC:

	IOC叫做控制反转,同时也叫做依赖注入,意思是:创建被调用者的工作不在有调用者完成,

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
bean的实例化方式:

	1.设值注入,
	2.构造方法方式
	3.静态工厂方法方式
	4.工厂bean的方式

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring在容器启动时就对相应的依赖类进行了实例化

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
id与name的区别:

	name里可以使用一些特殊的字符,而id不可以使用特殊字符

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
注入方式:

	1.set注入方式

	2.构造器注入

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何用通配符的方式应用多个配置文件:

	ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml*"); //在配置文件名的后面加一个 * 即可

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
bean与local的区别:

	bean是查找所有配置文件,而local只查找当前的配置文件

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对下面的这段applicationContext.xml配置的解释:

	<bean id="person" class="cn.wulin.domain.Person">
		<property name="id" value="1"></property>
		<property name="name" value="haha"></property>
		<property name="age" value="25"></property>
	</bean>
	<bean id="student" class="cn.wulin.domain.Student" parent="person" autowire="byType">
		<property name="studentNumber" value="1"></property>
		<property name="score" value="90"></property>
		<!--<property name="teacher" ref="teacher"></property>
	--></bean>
	<bean id="teacher" class="cn.wulin.domain.Teacher">
		<property name="teacherNumber" value="1"></property>
		<property name="salary" value="6666"></property>
	</bean>

	// autowire="byType" 表示自动查找属性bean,但是该bean必须唯一. 
	// parent="person" 表示继承 name="person" 的bean 

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring 的生命周期:

	xml中;

	<bean id="student" class="cn.wulin.domain.Student" parent="person" autowire="byType" init-method="init" destroy-method="destroy">
		<property name="studentNumber" value="1"></property>
		<property name="score" value="90"></property>
		<!--<property name="teacher" ref="teacher"></property>
	--></bean>

...........................
javaBean

	public class Student extends Person{
		private String studentNumber;
		private int score;
		private Teacher teacher;
		public Student(){
			System.out.println("实例化");
		}
		public void  init(){
			System.out.println("初始化");
		}
		public void  destroy(){
			System.out.println("销毁");
		}
	}

..............................
测试方法

	public void testPerson(){
		ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml");
		Student student=(Student) ac.getBean("student");
		System.out.println(student.getId() +" "+ student.getName() +" " +student.getAge()+ " " +student.getTeacher().getSalary());
		student.destroy();
	}
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么是OCP:

	开放关闭原则(开放:对扩展开放),(关闭:对修改关闭)

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
一个方法应该具有:

	职责单一,依赖倒置,ocp

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
类的字节码有哪些定义方式:

	类名.class == new 类名().getClass() == Class.forName("权限定名");

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
a)静态代理
    为什么会有代理？    
 	阻止对目标对象的直接访问
    如何代理？
	在代理对象中，写一个与目标对象一样的业务方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
AOP的xml的配置:

	1、导包 lib/aspectj/*.jar
	2、在xml文件中进行aop配置
	
	<bean name="logHandler" class="cn.scxh.service.proxy.LogHandler"></bean>
		<bean name="userService" class="cn.scxh.service.impl.UserServiceImpl"></bean>
	
		<aop:config>
			<!-- 声明一个切面 -->
			<aop:aspect id="logAspect" ref="logHandler">
				<!-- 声明切入点 -->
				<aop:pointcut expression="execution(* cn.scxh.service.impl.UserServiceImpl.add*(..))" id="pc" />
				<aop:after method="addLog" pointcut-ref="pc"/>
			</aop:aspect>
		</aop:config>	
		
		..........................................................................
		配置事务的多个切入点的案例:
		
		<!-- 事务的边界在service层,下面表明了事务的切入点 -->
	<aop:config>
		<aop:pointcut id="allManagerMethod"
			expression="execution(* cn.wulin.*.impl.*.*(..)) || execution(* cn.wulin.install.Installer.*(..))" />
		<aop:advisor pointcut-ref="allManagerMethod" advice-ref="txAdvice" />
	</aop:config>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
通知的类型:

	1、before
	2、after
	3、around

	public void addLog(ProceedingJoinPoint pjp){
			System.out.println("******* add log之前******");
			try {
				pjp.proceed();
			} catch (Throwable e) {
				e.printStackTrace();
			}
			System.out.println("******* add log之后******");
		}
	4、after throwing
	5、after returning

	拿方法的参数和签名：JoinPoint

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
AOP配置(Annotation)

	1、导包
	2、@Aspect
	public class LogHandler{
	
		@Pointcut("execution(* cn.scxh.service.impl.UserServiceImpl.*(..))")
		private void allAddMethod(){}// 第一个*表示返回值，是一个标记性的方法，主要作用就是为了下面的使用
	
		@After("allAddMethod()")
		public void addLog(){
			System.out.println("******* log handler******");
		}

	}

	3、启用aspectj对annotation的支持
		<bean name="logHandler" class="cn.scxh.service.proxy.LogHandler"></bean>
		<bean name="userService" class="cn.scxh.service.impl.UserServiceImpl"></bean>
	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
java中JDK的动态代理:

	代理的目标对象必须实现接口

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
1、AOP不是替代了OOP，它只是在OOP的基础之上更进化了一步 
2、为什么要AOP?
   为了让业务类与其他的辅助类的分类，为了让写业务人员更关注于核心业务的开发。为了将辅助的代码实现灵活的切入，就可以将辅助类做成一切面

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
AOP必须掌握的几个概念
	1、切面
	2、通知
	3、切入点
	4、连接点

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
关于cglib的使用:

	如果被代理的对象不是接口,则会自动用cglib代理.如果被代理的对象实现了接口,则他会自动选择动态代理

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何强制使用cglib代理:

	<aop:aspectj-autoproxy proxy-target-class="true"></aop:aspectj-autoproxy>

	在xml中配置上述标签即可;

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
















<=====================================================================================================================================================================>
三大框架整合后filter在xml文件中的配置问题:

	我们写的filter一定要放在struts2的filter的前面,否知无法用我们自定义的filter,因为是trusts2没有放行资源

<=====================================================================================================================================================================>

对java中注释及解释

     @SuppressWarnings("unchecked")  // 放在方法上,取消该方法里所有的黄色线警告,放在类上,取消该类了所有的黄色线警告.

   使用@Component注解可以定义一个bean，bean的名称可以不写，默认为类的简单名称且第1个字母小写。

   以下几个注解的作用一样，只是名称不一样，是为了区分bean的作用。  
	@Component
	@Controller	//在controllerce层
	@Service   	//在service层
	@Repository   // 在dao层   
	@Autowired   //利用该注解来省略 private 类型 属性的get与set方法,该注解是spring框架提供的.使用了该注解后,spring后向通过查找classType类型去找,如果没有找到就会按			照name类型去查找.如果查找不到就抛出异常,但是该注解有一个required=false属性可以设置,如果没有查找到也不用抛出异常的设置.

	//这几个注解表示创建对应的类对象实例

	@Resource是用于注入依赖的bean：    //表示的获得对应类对象实例,他的查找方式与spring的查找方式恰好相反,是先找查找name类型,如果没有查找到,在取查找classType类型,值		官方的规范.
	可以通过name属性指定所需要的bean的名称，如果找不着，则抛异常。
	或可以通过type属性指定所需要的bean的类型，
		如果只有一个bean匹配这个类型，则就是他.
		如果有多个bean匹配这个类型，则使用名称与字段或属性相同的，如果名称都不与当前属性或字段名相同，则抛异常。
	或可以什么都不指定，默认是先按当前字段或属性的名称查找，如果找不到，再按类型查找，就抛异常。
	
	@Scope注解用于指定bean的生命周期.  scope="prototype/singleton"

	@Transactional  表示开启事务,一般用在service层   //这个应用的类是:org.springframework.transaction.annotation.Transactional
	
	@Deprecated : 标示一个方法或属性过时

<=====================================================================================================================================================================>
用spring的方式加载一个preperties文件的如何做?

	@Service
	@propertySource(value="classpath:test.preperties")
	public class TestLoadPreperties {

	}

	// 注意 : 该方式还仅供参考,如果要使用,该的查询相关的资料才能使用.这里只是一个模型

<=====================================================================================================================================================================>
返回空集合的两种写法:
	
	return new ArrayList<T>(); // 不专业的写法
	return Collections.EMPTY_LIST;  //  专业的写法

<=====================================================================================================================================================================>

通过反射过得T的真实类型的写法:
	 
	public class BaseDaoImpl<T> implements BaseDao<T>{

		private Class<T> clazz;//这是一个问题

		public BaseDaoImpl(){

		//通过反射过得T的真实类型

          ParameterizedType pt=(ParameterizedType) this.getClass().getGenericSuperclass(); 

		//这里的this表示的子类了new 父类的对象,在java类中,其实所有的this都是这个意思

		this.clazz=(Class) pt.getActualTypeArguments()[0];

		//这里的this.clazz=(Class) pt.getActualTypeArguments()[0];之所以是数组是因为泛型也可以定义多过类型,

		//如 : public class BaseDaoImpl<T> implements BaseDao<T,A,B,C,D,E>{  } [0]表示第一个

	}
    }	

<=====================================================================================================================================================================>

提示某地放还需要修改的写法:

	// TODO haha
	// FIXME hehe

<=====================================================================================================================================================================>

解决字符串为null值或为""空字符串的便捷方法:

	public static boolean isEmpty(String str){
		if(str==null||"".equals(str)){
		return true;
	}
	return false;
}

<=====================================================================================================================================================================>

单例设计模式范例:

    public class StudentModel extends AbstractTableModel {
	private static StudentModel studentModel;
	private StudentModel(){}
	public synchronized static StudentModel getInstance(){
		if(studentModel==null){
			studentModel=new StudentModel();
		}
		return studentModel;
	}
    }

<=====================================================================================================================================================================>
动态改变验证码的方法:

	<img alt="" id="memberSignupCaptchaImg"
																						class="memberSignupCaptchaImg"
																						onclick="javascript:src='${pageContext.request.contextPath}/jsp/validate/validateNumber.jsp?date='+new Date()"    //加一个参数是为了去掉缓存
																						title="看不清，换一张"
																						src="${pageContext.request.contextPath}/jsp/validate/validateNumber.jsp">

<=====================================================================================================================================================================>






































<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

																	spring 4 mvc 的学习笔记(springmvc)
<=====================================================================================================================================================================>
是用springmvc的下载案例:

	/**
	 * @Description 导出数据
	 * @param id
	 * @return ResponseEntity<byte[]>
	 * @throws Exception
	 */
	@RequestMapping("exportData")
	public ResponseEntity<byte[]> exportData(@RequestParam("id") String id) throws Exception{
		File file =  zfxzcfService.exportDocJbspd(id);
		return SpringUtil.getResponseEntityByFile( file);
	}
	
	
	//SpringUtil的工具类
	public class SpringUtil {
		public static ResponseEntity<byte[]> getResponseEntityByFile(File file) throws Exception {
			return getResponseEntityByFile(file, file.getName());
		}
		
		/**
	 * 构建服务器传输给客户端的文件信息
	 * @param fileName 文件名为空则显示当前时间
	 * @param resource  word 文件的路径
	 * @return
	 * @throws Exception
	 */
	public static ResponseEntity<byte[]> getResponseEntityByFile(File file,String fileName) throws Exception {
        FileInputStream stream = new FileInputStream(file);
        byte[] cbyte = IOUtils.toByteArray(stream);
        stream.close();
		HttpHeaders responseHeaders = new HttpHeaders();
    	responseHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM);
    	responseHeaders.setContentLength(cbyte.length);
    	responseHeaders.set("Content-Disposition", "attachment;filename=\""+URLEncoder.encode(fileName,"UTF-8")+"\"");
		return new ResponseEntity<byte[]>(cbyte, responseHeaders, HttpStatus.OK);
	}
}

<=====================================================================================================================================================================>






















<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

常犯的错误笔记:
<=====================================================================================================================================================================>

1.当发生如下错误时: 那就是PreparedStatement.setXX();向sql语句传参时,少传了一个,即少执行了这样一条语句:PreparedStatement.setXX();

	抛出的异常错误:

		java.sql.SQLException: 索引中丢失  IN 或 OUT 参数:: 2

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.当我们用equals()放比较两个字符串是否相等时,应注意用trim()方法将字符串的前后空格去掉.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

3,当一个对象中没有内容时,我们只能用 object==null或object!=null,而不能用object.isEmpty()去判断,这个object.isEmpty()方法主要是用在集合与数组中,但是集合与数组也必须有对象
	只是他们的内容可以为空.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

4.在gui编程使用 监听 与匿名内部类 组合的经典错误:

	那就是在 匿名内部类 的方法中调用 匿名内部类 所属的方法 ,而监听器又将所创建的 匿名内部类 对象放在一个 域数组对象 中,同时用遍历该 域数组对象 中的内容的方式去调用
	匿名内部类中的方法,所有 当监听 接收到 一个行为 就会以 倍数 的方法 创建 匿名内部类 对象,同时又在以 倍数 的方法调用 匿名内部类中的方法 ,这是一个经典又可怕的错误.
	一定要记住的是,其实监听器所用的 匿名内部类 对象有且只有一份,否则 也不会说监听与 匿名内部类 是完美的组合. 而且在gui编程中 组件(即对象)一旦创建就要小心使用,千万        不能重复创建和在窗体中重复显示.而若要操作某个组件(即对象)的某些行为,就要先得到 原组件(即原对象) ,然后用这个 原组件(即原对象) 去调相应的方法.千万不要想着我创建
	一个新的组件(即新的对象) , 然后用这个 新的组件(即新的对象) 去调相应的方法,再然后去覆盖窗体中原组件(即原对象),因为窗体显示的组件不存在覆盖于被覆盖关系,而对象中
	更是这样. 

		当然.这里要特别提醒:千万不要被放在 java虚拟机中的栈内存中的 引用变量 给迷惑了



<---------------------------------------------------------------------------------------------------------------------------------------------------------------------















<=====================================================================================================================================================================>
<=====================================================================================================================================================================>

随机数的使用:

	Random r=new Random(); 
	int i=r.nextInt(100);表示获得[0,100)的随机整数.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
	

<=====================================================================================================================================================================>














<=====================================================================================================================================================================> 
java基础:

<=====================================================================================================================================================================> 
<=====================================================================================================================================================================> 
java语法基础

	




<=====================================================================================================================================================================> 
面向对象

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
重写方法的返回值:

	返回值类型要一致或要兼容,即子类的返回值类型要是父类的返回值类型的子类



<=====================================================================================================================================================================> 
异常
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
异常组织图:

	throwable--->error,Exception
	exception--->RuntimeException,其他异常

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
try关键字一般与那些关键字一起使用:

	try--catch一般在一起使用,当然try--finally亦可以一起使用

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
当try块里面有return与finally一起使用是这样的?

	一般先执行finally块,在执行return语句

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
当try块里有return,finally里面也有return语句时,程序是这样执行的.

	在这种情况下,先执行try块里的return,但它并不直接就返回,而是将return返回的值放在一个变量里,这时它在执行finally块里的语句,当程序执行到finally语句里的return语句时,		这时程序一样会把return的返回值放在之前的变量里,这时程序就将之前变量你的值给覆盖了,所有最后返回的值是执行finally你的return语句时的值.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
异常对重写方法的影响?

	1.重写的方法可以不抛出异常,也可以抛出与父类一样的异常,当然也可以抛出父类异常的子类异常,个数不限

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------








<=====================================================================================================================================================================> 
常用类


<=====================================================================================================================================================================> 
容器

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
vector与ArrayList的区别:

	vector是线程安全的,而ArrayList是线程不安全的.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
HashSet使用什么实现的?

	hashSet使用HashMap实现的

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
hashcode与equals的关系:

	当hashcode相等时,equals不一定相等.而equals相等时,则hashcode一定相等

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
TreeSet实现排序的两种方式:

	1.在javabean中实现comparable接口
	2.在所需要的排序的类中实现comparator接口

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
HashMap的实现原理:

	数组加链表

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
HashMap与HashTable的区别:

	1.hashMap是线程不安全,而HashTable是线程安全的
	2.HashMap的父亲是AbstractMap,而HashTable的父亲是Dictionary
	3.HashMap的键值可以为空,而HashTable的键值不可以为空

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------















<=====================================================================================================================================================================> 
io

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么是序列化:

	把一个对象保存起来就叫做序列话

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
transient的作用:

	transient 让某个属性不被序列化

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------






<=====================================================================================================================================================================> 
线程	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
线程有那几个状态:

	就绪,运行,阻塞,死亡 这4个状态

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
线程如何停止:

	用一个标记

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
线程有一个设计模式是:

	静态代理

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
线程中的锁锁的是什么:

	线程中的锁锁的永远是一个对象

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
wait方法与sleep方法分别属于哪一个类:

	wait()方法属于object类,而sleep()属于Thread类

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
wait()方法与sleep()方法的区别:

	1.wait()方法属于object类,而sleep()属于Thread类
	2.当一个线程用wait()进行阻塞是,wait()会释放锁,而若用sleep(),则sleep()不会释放
	3.wait()只有在锁的前提下才能谈wait(),而sleep()则不用

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------













<=====================================================================================================================================================================> 
网络

	iso:国际化标准组织
	osi:开放系统互联

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
TCP/IP模型(4层)

	物理层,网络层,传输层,应用层

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
7层模型:

	物理层,网络层,传输层,应用层,数据链路层,会话层,表示层	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
为什么用TCP协议进行传输

	安全性高(即三次握手),属于传输层

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
为什么用UDP协议进行传输

	效率高,但安全性低,因为他只管往外扔信息,属于传输层

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
IP协议属于那一层:

	属于网络层

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------



<=====================================================================================================================================================================> 
servlet:

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
servlet与cgi的区别:

	servlet的性能要高一些?因为servlet用是多线程

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何写一个过滤器:

	implements Filter接口

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
什么时候调用doGet,什么时候调用doPost

	客户端发起的是什么请求就调用什么方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
什么时候用get,什么时候用post

	如果希望客户端发起请求后地址栏不变,或如果用form标签提交表单时表单中含有file文件标签,就用post,其他情况可以根据情况再进行选择

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
jsp与servlet关系?

	jsp本身就是servlet.只是在mvc模式中将他们分离出来,让jsp主要做显示,让servlet做逻辑,

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
将jsp转换为servlet是谁做的?

	是服务器做的

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	


















<=====================================================================================================================================================================> 
<=====================================================================================================================================================================> 

对于做OA系统时的一些总结:
<=====================================================================================================================================================================> 

								总结
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在cmd命令中显示mysql数据库的信息:

	输入 status

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在创建mysql数据库是就指定其编码?

	create database mysql数据库名称 default character utf8;		

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何调整MyEclipse中的格式化后xml一行显示多少行?

	路径:window/preferences/myEclipse/files and Editors/xml/xml source
	
	然后将选项 Line width 修改即可

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
<a>标签其实还可以这样写:

	<a href="roleAction_delete.action?id=<s:property value="id"/>" onclick="return confirm('确定删除?')">
				删除
			</a><br/>

<----------------------------------------------------
同样可以这样写

	<s:a action="roleAction_delete" onclick="return confirm('确定删除?')">
				<s:param name="id" value="%{id}"></s:param>
				删除
			</s:a><br/>
		</s:iterator>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
是否可以用EL表达式输出用struts2包装过得4大域对象中的值?

	如果用的不是struts2 的标签,则可以用EL表达式输出其值,如果是放在值栈的栈中的对象,同时用的是struts2 的标签,则可以使用这样的形式 %{id}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
下面的写法是为什么?

	<s:iterator value="roleList">
			<s:property value="id"/>
			<s:property value="name"/>
			
			<s:a action="roleAction_delete" onclick="return confirm('确定删除?')">
				<s:param name="id" value="%{id}"></s:param>
				删除
			</s:a><br/>
		</s:iterator>

.........................................................

	答:因为用struts2标签遍历出来的值是先放在放在值栈的栈中,如果struts2遍历加了var属性,则遍历出来的值还要放在值栈的map中的page域对象中,因此下面的<s:property 	value="id"/>标签可以换为 ${id} 表达式.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
在struts2的自定义标签里面我们只能使用ognl表示

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
为什么我们一般都选用<s:form>标签?

	因为选用<s:form>标签具有自动回显的功能

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
栈(即对象栈)中一般放什么值?

	对象栈一般放一个对象

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
有表单提交功能且是一张图片的写法?

	<input type="image" src="${pageContext.request.contextPath}/style/images/save.png"/>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
解释一下下面的<s:select>标签的关键属性:

		<s:select name="departmentId" cssClass="SelectStyle"
                            	list="#departmentList" listKey="id" listValue="name"
                            	headerKey="" headerValue="请选择部门">
                            </s:select>

	// name表示用于表单传值的名称;cssClass相当于一般标签中的class;list表示用于表单回显时的集合;listKey表示传回后台的值,listValue表示表示用于前台显示的值,headerKey		表示默认选中时传回后台的值,headerValue表示默认选中时前台显示的值,而在这里list属性集合从后台得到的值是一个list集合,id表示list集合中被选中的对象的属性,listValue
	中的name同理,这里解释一下为什么被选中的对象可以直接使用其当中的属性,因为被选中的对象是放在对象栈的顶部的.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
解释一下下面的<s:rodio>标签:

	1.<s:radio name="gender" list="%{ {'男', '女'} }"></s:radio>
	2.<s:radio name="gender" list="%{list}" listKey="id" listValue="name"></s:radio>
	3.<s:radio name="gender" list="#{'00':'男', '22':'女'}"></s:radio>
	4.<s:radio name="gender" list="%{#myMap}" listKey="key" listValue="value"></s:radio>

	//list表示用于回显或者显示的集合,可以是List或map,
	1.表示用ognl表达式构建一个list集合,同时表示回显值与显示值一样;
	2.表示用从后台传回一个list集合,用对象中的id作为listKey的值,用name作为listValue的值;
	3.表示用ognl表达式构建一个map集合,默认用key作为回显值,用value作为显示的值
	4,表示用从后台传回一个map集合,使用key作为回显值,使用value作为显示值

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
格式：

	EL表达式			JSP中${表达式}
	OGNL表达式			Strtus2中（Struts2的自定义标签中、struts.xml...）
	Struts2的自定义标签的属性值中	%{表达式}
	struts.xml中			${表达式}
	语法：
		%{name}
		%{#name}
		%{#user.name}
		#{'k':'v', 'k2':'v2'}
		{'e1', 'e2'}

	%{	#{'k':'v', 'k2':'v2'} }
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
用<s:select>的多选下拉列表如何将值传回服务端:

	<s:select name="roleIds" cssClass="SelectStyle"
                        		multiple="true" size="10" 
                        		list="#roleList" listKey="id" listValue="name">
                            </s:select>

	//他会以数组的形式传回服务端
	后台的代码:private Long[] roleIds; 当然要提供get与set方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
这个异常：org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: org.joshua.ss.entity.SysUsers.sysUsersRoleses, no session or session was closed

	原因：在hibernate的映射关系中由于延迟加载，之前的操作使session已经关闭，所以加载set属性时无可用session
	解决办法：在映射文件中设置set属性 lazy='false'
 
	<set name="sysUsersRoleses" inverse="true" cascade="all"<span style="color: rgb(255, 0, 0);"> lazy="false"</span>>  
            <key>  
               <column name="USER_ID" length="32" />  
            </key>  
           <one-to-many class="org.joshua.ss.entity.SysUsersRoles" />  
       </set>  
	   
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------   
如何选择抛出异常的范围:

	对于一段代码中,可能会抛出多个异常,这时我们宁愿将异常抛大些,也不要抛的太小,因为有些时候可能抛出的异常不是你所抛出的范围

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何将List集合转换为Set集合:  用相反的方式也可以将set集合转换为List集合

	方式一:Set<Role> roleSet=new HashSet<Role>(roleList);
	
	方式二:Set<Role> roleSet=new HashSet<Role>();
	roleSet.addAll(roleList);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查询多个id值对应的集合值:

	调用getByIds(Long[] ids);方法

	List<Role> roleList = roleService.getByIds(roleIds);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
<s:select>的多选下拉列表如何回显值:

			<s:select name="roleIds" cssClass="SelectStyle"
                        		multiple="true" size="10" 
                        		list="#roleList" listKey="id" listValue="name">
                            </s:select>
	
	//在Action中定义属性private Long[] roleIds; 当然要为该属性提供set与get方法;同时为该属性赋值即可

	if (user.getRoles().size() > 0) {
			roleIds = new Long[user.getRoles().size()];
			int index = 0;
			for (Role role : user.getRoles()) {
				roleIds[index++] = role.getId();
			}
		}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
ognl表达式其实也可以这样用:

	 <s:form action="userAction_%{id == null ? 'add' : 'edit'}">
	<s:if test="#parent != null">

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
hql的隐似自关联查询?

	public List<Department> findChildren(Long parentId) {
		return getSession().createQuery(//
				"FROM Department d WHERE d.parent.id=?")//千万不要被d.parent给懵了,这条语句采用了隐似连接查询,隐似连接查询与显示连接查询是不一样的
				.setParameter(0, parentId)//			具体区别见书上.这条语句表示的意思是查询Department类的所有实体,条件是实体的parent属性	
				.list();					的属性Id要等于parentId的值,这是隐似查询的思维,对应显示查询的思维我现在还不能下具体的
										结论.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如果Action中有属性,而Action中的一个方法在返回是又有ActionContext.getContext().getValueStack().push(department);,那么对象栈的顶部究竟放的是哪一个对象或属性?

	这个问题我还没有测试过,还不能下结论.现在用的时候,只能先尽量避免这种情况的出现.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
struts.xml中是否可以用ognl表达式?

	答案是肯定的,jsp的<struts2>标签是如何使用ognl表达式的,struts.xml中就可以如何使用ognl表达式,如下的表达式是直接取用对象栈的栈顶属性.
	<result name="toList" type="redirectAction">departmentAction_list?parentId=${parentId}</result>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
中文的全角空格是可以在jsp页面中全部显示出来的

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
对象 xxx.hbm.xml文件中的对set集合的懒加载与排序的列子:

	<set name="children" lazy="false" cascade="delete" order-by="id"> //order-by="id"表示用Id进行排序
			<key column="parentId"></key>
			<one-to-many class="Department" />
		</set>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何查看mysql中的帮助命令:

	在cmd中启动mysql后,直接输入help,然后点击回车即可.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
打开cmd,如何打开cmd中某个目录下的内容:以下是示例:

	1.C:\Users\lenovo>cd C:\Users\lenovo\Desktop\学习

	2.C:\Users\lenovo\Desktop\学习>dir

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
如何在cmd命令中执行java文件;

	1.首先找到该java文件所在的classes目录,即:D:\java\javaTools\myeclipse\myeclipse-8.5.0\workspace8.5\ItcastOA\WebRoot\WEB-INF\classes>
	2.然后再该目录后输入:java cn.itcast.oa.install.MyInstaller
	3.执行 2 是有条件的,即 环境变量中的classpath路径前面有 ' .; '(点冒号);
	4.在cmd命令中同过 set classpath 命令来查看环境变量中的classpath路径
	5.在cmd命令中输入 cd .. 是将当前的目录后退一级
	6.如果我们不在classes路径下的,而是在WEB-INF目录下,这我们要自己指定classPath路径 :java -classpath classes/ cn.itcast.oa.install.MyInstaller ;但是这种用法也是有
		限制的,也就是它只能在D:\java\javaTools\myeclipse\myeclipse-8.5.0\workspace8.5\ItcastOA\WebRoot\WEB-INF 该目录下有效,

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何建立一个 .bat文件:

	文件名: myTest.bat

	文件的内容:

		rem 这个rem命令是注释的意思.而 echo off是指不显示命令行的具体细节,parse 指的是暂停的意思
		echo off
		rem 执行安装程序
		java -classpath .;WebRoot/WEB-INF/classes cn.itcast.oa.install.MyInstaller

		rem 暂停
		pause

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于上面的classPath路径,我们应该将bat文件放在什么地方执行

	应该将.bat文件放置工程目录下: D:\java\javaTools\myeclipse\myeclipse-8.5.0\workspace8.5\ItcastOA

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何使用Md5摘要:

	DigestUtils.md5Hex("admin"); // 要使用MD5摘要

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
标签中<s:checkBox>与<s:checkBoxList>回显值分别是什么?
 
	<s:chechBox>标签的回显值是Boolean 的值,而 <s:chechBoxList>标签的回显值是String[]类型
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
<s:checkBoxList>使用举例:

  	1.jsp中 <s:checkboxlist name="privilegeIds" list="privilegeList" listKey="id" listValue="name"></s:checkboxlist>
	2.Action中 private Long[] privilegeIds; 当然一定要为其提供set与get方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
ognl在checkbox中的用法:

	<s:iterator value="children">
		<li>
			<input type="checkbox" name="privilegeIds" value="${id}" id="cb_${id}" <s:property value="%{id in privilegeIds ? 'checked' : ''}"/> >
			<label for="cb_${id}"><span class="folder">${name}</span></label>
		</li>
	</s:iterator>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
让一颗树进行切换的显示的方法:

	function itemClick( itemDiv ){
		 $(itemDiv).next().toggle();
			}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
jquery中常用的显示与隐藏;

	show();与hidden();

	而toggle();是显示与隐藏的切换方法.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
redirectAction与redirect的区别?

	redirectAction是重定向到Actin类,而redirect是重定向到页面.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何动态加载窗体:

	<frameset rows="100,*,25" framespacing=0 border=0 frameborder="0">
		<frame noresize name="TopMenu" scrolling="no" src="${pageContext.request.contextPath}/homeAction_top.action">
		<frameset cols="180,*" id="resize">
			<frame noresize name="menu" scrolling="yes" src="${pageContext.request.contextPath}/homeAction_left.action">
			<frame noresize name="right" scrolling="yes" src="${pageContext.request.contextPath}/homeAction_right.action">
		</frameset>
		<frame noresize name="status_bar" scrolling="no" src="${pageContext.request.contextPath}/homeAction_bottom.action">
	</frameset>

	*特别注意:以上的src的地址是一个动态的地址

.............................................................
与之对应的Action代码:

	public String index() throws Exception {
		return "index";
	}
	public String top() throws Exception {
		return "top";
	}
	public String bottom() throws Exception {
		return "bottom";
	}
	public String left() throws Exception {
		return "left";
	}
	public String right() throws Exception {
		return "right";
	}

...................................................
与之对应的struts.xml代码:

	<action name="homeAction_*" class="homeAction" method="{1}">
		<result name="{1}">/WEB-INF/jsp/homeAction/{1}.jsp</result>
	</action>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何让页面一加载就让登录文本框获得焦点:

	$(function(){
		document.forms[0].loginName.focus();
	});

................................................
对应的Html代码:

	<s:textfield name="loginName" size="20" tabindex="1" cssClass="TextField required" id="loginNameInput" />

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	服务器端验证

Action中：
	addFieldError("fieldName", "message");  //添加错误消息
	addFieldError("login",  getText("login.failed")); //从配置文件中加载国际化后的错误消息

Jsp中：
	<s:fielderror fieldName="fieldName"/> //显示指定的错误消息
	<s:fielderror/> //显示所有的错误消息

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
web.xml中几个重要的配置:

	*注意:下面配置顺序不能变;否则会出现一些我们意想不到的错误.
	
	<!-- 配置Spring的监听器，用于初始化ApplicationContext对象 -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext*.xml</param-value>
	</context-param>
	
	
	<!-- 用于初始化数据的监听器 -->
	<listener>
		<listener-class>cn.itcast.oa.listener.InitServletContextListener</listener-class>
	</listener>
	
	
	<!-- 配置Spring的OpenSessionInViewFilter，以解决懒加载异常的问题 -->
	<filter>
		<filter-name>OpenSessionInViewFilter</filter-name>
		<filter-class>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>OpenSessionInViewFilter</filter-name>
		<url-pattern>*.action</url-pattern>
	</filter-mapping>
		


	<!-- 配置Struts2的主过滤器 -->
	<filter>
		<filter-name>struts2</filter-name>
		<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>struts2</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

	
	
	<!-- 配置要访问的首页-->
	<welcome-file-list>
		<welcome-file>index.jsp</welcome-file>
	</welcome-file-list>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
为什么先前写几个base类我们也没有向Spring的 web容器中注入实例,而我们依然可以用 @resource 取得web容器中的实例呢?

	那是因为我们用相应的已经向Spring的 web容器注入实例的类去接承了他们,因而他们成了子类的一部分,所以可以.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于没有向Spring的 web容器中注入实例类,我们如何取得相应的Spring的 web容器中的实例.范例如下

	ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(application);
	PrivilegeService privilegeService = (PrivilegeService) ac.getBean("privilegeServiceImpl");

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
@Service这类似没有指定name值得向Spring的 web容器中注入实例的注解的默认name值是多少?

	他们其实就是所属类的类名,只是类名的第一个字母要小写.例如

	@Service
	@SuppressWarnings("unchecked")
	public class PrivilegeServiceImpl {

	...

	}

	其实这时默认的@Service("name= PrivilegeServiceImpl ")就是这样的;name= PrivilegeServiceImpl	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何解决懒加载问题?

	1.首先我们应考虑使用过滤器,但过滤器只能解决一个请求的问题.在web.xml中进行配置.

		<!-- 配置Spring的OpenSessionInViewFilter，以解决懒加载异常的问题 -->
		<filter>
			<filter-name>OpenSessionInViewFilter</filter-name>
			<filter-class>org.springframework.orm.hibernate3.support.OpenSessionInViewFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>OpenSessionInViewFilter</filter-name>
			<url-pattern>*.action</url-pattern>
		</filter-mapping>

	2.如何是多个请求的,用过滤器将无法解决,我们只能使用在 xx.hbm.xml 配置文件中对应的标签中使用 lazy="false" 的方式来解决了

		<set name="children" lazy="false" cascade="delete" order-by="id"> //order-by="id"表示用Id进行排序
			<key column="parentId"></key>
			<one-to-many class="Department" />
		</set>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
jquery中的not( jquery的对象x )方法使用:

	该法的意思是在所有找到的jquery对象中排除对象为x的对象;

	$(".MenuLevel2").not( $(menuDiv).next() ).hide();
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
常用的工具类:

	*注意:下面的这些类在任何类中都可以直接使用

	ActionContext,ServletActionContext,WebApplicationContextUtils,DigestUtils

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对应用原生的(request,session,application)这大域对象中所封装的值可以用Struts2中已经解耦的(request,session,application)这几个域对象也获取他们中的值,即

	ActionContext...

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
struts2 的标签前中还可以直接调用方法?

	<s:if test="#session.user.hasPrivilegeByName(name)">

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
用 "xx".equals(引用变量); 与 '引用变量'.equals("xx"); 的区别:

	1.用"xx".equals(引用变量);这种方式不会抛出 空指针异常 ,

	2.用'引用变量'.equals("xx");这种方式,如果 '引用变量' 为空时 会抛出空指针异常

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何根据自定义的标签找到对应的类: 例如.<s:a>..</s:a>

	1.找到<s:a>标签对应的 tld文件,去找他对应的类即可

	2.将鼠标的光标放在<s:a>上,按住ctrl键,等待<s:a>下面有一条横线时,点击即可

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
显示类当做的成员的快捷键是 ctrl+o;

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
显示某个类的所有父类的快捷键是 ctrl+T ,但条件是需要将鼠标的光标放放在类名上

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对与自定义标签我们需要重写的两个方法:

	public int doStartTag() throws JspException {}

	 public int doEndTag() throws JspException {}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何为<s:a>加上权限判断:

	1.为每一个<s:a>标签都加上if,else 判断
	2.自己定义一个 <a>标签
	3.重写<s:a>标签的类,并重写里面的 doEndTag() 方法

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对 doEndTag() 方法的两个常量解释:

	EVAL_PAGE; 如果没有权限，就不显示当前<a>标签，只是继续执行页面中后面的代码

	SKIP_PAGE: 如果没有权限，就不显示当前<a>标签，并且跳过页面中后面的代码

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
拦截器也可以这样使用?

		<interceptors>
			<!-- 声明一个拦截器 -->
			<interceptor name="checkePrivilege" class="cn.itcast.oa.interceptor.CheckPrivilegeInterceptor"></interceptor>

			<!-- 重新定义defaultStack拦截器栈，需要先判断权限 -->
			<interceptor-stack name="defaultStack">
				<interceptor-ref name="checkePrivilege" />
				<interceptor-ref name="defaultStack" />
			</interceptor-stack>
		</interceptors>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于struts2中命名空间的配置:

	一般情况下,命名空间的配置我们都是以斜线(/) 开头,但一定不能以斜线结尾

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对下面这段代码的理解

	// 获取当前访问的URL，并去掉当前应用程序的前缀（也就是 namespaceName + actionName ）
		String namespace = invocation.getProxy().getNamespace();
		String actionName = invocation.getProxy().getActionName();
		String privilegeUrl = null;
		if (namespace.endsWith("/")) {
			privilegeUrl = namespace + actionName;
		} else {
			privilegeUrl = namespace + "/" + actionName; 
		}

		// 要去掉开头的'/'
		if (privilegeUrl.startsWith("/")) {
			privilegeUrl = privilegeUrl.substring(1);
		}

	*以上的代码与我理解的有些不一样,但是他之所有可以是因为他的命名空间都是 斜杠(/), 对应 例如 /aa 这类的情况我还没有测试.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于javaBean,我们一般要将其实现序列化接口,	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何刷新窗口:

	window.location.reload(true);表示刷新当前窗口

	window.parent.location.reload(true); 表示刷新我的父亲的窗口

	// 在被嵌套时就刷新上级窗口
		if(window.parent != window){
			window.parent.location.reload(true);
		}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
在js文件中用于包含多条js的关键语句:

	document.write("<script language="javascript" src="${pageContext.request.contextPath}/script/jquery_validate/jquery.validate.js"></script>");

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
这是hibernate的一个高级用法:

	public void save(Forum forum) {
		// 保存到DB，会生成Id的值
		getSession().save(forum);  //执行到完这条语句后,forum对象中的值会被重新赋值

		// 指定position的值为最大 // SELECT MAX(f.position) FROM Forum f
		forum.setPosition(forum.getId().intValue());

		// 因为是持久化状态，所以不需要调用update()方法。因为forum对象中的值被更新了,而Session还没有被关闭,所有在Session关闭时,会把更新的值刷新到数据库去
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于sql语句或者hql语句.我们一定要遵从一个从左到右的规则,一就是说系统的执行顺序是从左到右,从上到下的

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于下面的这条hql语句的解释:

	FROM Forum f WHERE f.position<? ORDER BY f.position DESC

	//查找Forum类的所有实例,但必须满足f.position<?这个条件,然后再对查出的语句进行排序
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
查询所有权限URL的集合（不能有null，不能重复）,并且只查询一个对象中某一个字段的hql的写法:

	public List<String> getAllPrivilegeUrls() {
		return getSession().createQuery(//
				"SELECT DISTINCT p.url FROM Privilege p WHERE p.url IS NOT NULL")//
				.list();
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何用hql语句查询一个对象的范例:

	Forum other = (Forum) getSession().createQuery(// 我上面的那个Forum
				"FROM Forum f WHERE f.position<? ORDER BY f.position DESC")//
				.setParameter(0, forum.getPosition())//
				.setFirstResult(0)//
				.setMaxResults(1)//
				.uniqueResult();
	<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对下面这两行 css 代码的解释:

	text-decoration: underline; //为对应的元素加上下划线  ,该属性在css文档的 属性/字体的分类中
    		cursor: pointer; //将光标设为手型  ,该属性在css文档的 属性/其他的分类中

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对应a标签中的 disabled 属性不起作用,如何解决

					<s:if test="#status.first">
						<span class="disabledA">上移</span>
					</s:if>
					<s:else>
						<s:a action="forumManageAction_moveUp?id=%{id}">上移</s:a>
					</s:else>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
用的映射文件 xx.hbm.xml 处理对应大文本和时间的问题:

	xml中

		<property name="content" type="text" length="50000"/>  //这里的类型指的是数据库中的类型

		<property name="postTime" type="timestamp"/> //这里的类型指的是数据库中的类型

..............................................
javaBean中

	private String content;// 内容

	private Date postTime;// 发表时间

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
这里使用了单向映射:

	<!-- author属性，本类与User的多对一 -->
		<many-to-one name="author" class="User" column="authorId"></many-to-one>  //User中没有与之对应的一对多映射

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
这里也使用呢单向关联:

	<!-- lastReply属性，本类与Reply的一对一 -->
		<many-to-one name="lastReply" class="Reply" column="lastReplyId" unique="true"></many-to-one>	
		
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
用<s:..>标签对日期时间的控制显示实例:

	<s:date name="%{lastTopic.postTime}" format="yyyy-MM-dd HH:mm:ss"/>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
当没有集合时,<s:iterator>标签也可以这样写:

	<s:iterator begin="1" end="14" var="num">
		<td width="50" style="border-bottom:0 solid #ffffff">
			<input type="radio" name="faceIcon" value="${num}" id="r_${num}"/>
			<label for="r_${num}">
				<img width="19" height="19" src="${pageContext.request.contextPath}/style/images/face/${num}.gif" disabled="true" align="absmiddle"/>
			</label>
		</td>
	</s:iterator>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对下面代码的解释:

	<input type="radio" name="faceIcon" value="${num}" id="r_${num}"/>
	<label for="r_${num}">
	<img width="19" height="19" src="${pageContext.request.contextPath}/style/images/face/${num}.gif" disabled="true" align="absmiddle"/>
	</label>
	
	//<label for="r_${num}">该标签的作用是,我点击图片是也可以让radio的标签选中

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对于jsp表单提交时,有的字段没有在我们绑定的javaBean中,而我们在Action中提供了这些字段的set与get方法,这是这样运行的.

	当我们提交表单时,在到达Action之前会经过许多的过滤器与拦截器,在经过拦截器时,对于modelDriver中有的字段,拦截器会将对应的值赋给相应的字段,对于在Action中提供了
		set与get方法的字段,拦截器会将这些字段赋给相应的字段,并且把这些字段捆绑在一起放在对象栈的栈顶,所有我们可以使用放在modelDriver中的字段,也可以使用Action中
		的字段.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对下面这条hql语句的解释:

	FROM Topic t WHERE t.forum=? ORDER BY (CASE t.type WHEN 2 THEN 2 WHEN 1 THEN 1 ELSE 0 END) DESC, t.lastUpdateTime DESC"):

	//表示查找 Topic 类 ,条件是 t.forum = ? 且按照 case满足的条件先进行降序排序,如何case的值相同,则在按照t.lastUpdateTime 进行降序排序

	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对 与 case 的理解:

	范例:在emp表中,为工作为'CLERK'的员工加薪200,为工作为'SALESMAN'的员工加薪300

	

	方法一: 用 case

	select job,sal,case job when 'CLERK' then sal+200
				when 'SALESMAN' then sal+300
				else sal
				end
	from emp

.......................................   //case 语句组成的字段并不是一个特定的字段,这个字段是有自己拼接而成的

	select job,sal,(case job when 'CLERK' then 'hshs'
        when 'SALESMAN' then 'xixi'
        else 'jjj'
        end) as mysay
	from emp

.....................................

//这个case 表示的意思是 : if(){} if(){} ...else{}..

...............................................
使用示例：

mysql> select id,name, (gender) as '性别' from itcast_user;
+----+------------+------+
| id | name       | 性别 |
+----+------------+------+
| 19 | 张三       | 1    |
| 20 | 小红       | 2    |
| 21 | 超级管理员 |      |
+----+------------+------+
3 rows in set (0.00 sec)

mysql> select id,name, (CASE gender WHEN 1 THEN '男' WHEN 2 THEN '女' ELSE '其他' END) as '性别' from itcast_user;
+----+------------+------+
| id | name       | 性别 |
+----+------------+------+
| 19 | 张三       | 男   |
| 20 | 小红       | 女   |
| 21 | 超级管理员 | 其他 |
+----+------------+------+
3 rows in set (0.00 sec)

mysql> select id,name, (CASE WHEN gender=1 THEN '男' WHEN gender=2 THEN '女' ELSE '其他' END) as '性别' from itcast_user;
+----+------------+------+
| id | name       | 性别 |
+----+------------+------+
| 19 | 张三       | 男   |
| 20 | 小红       | 女   |
| 21 | 超级管理员 | 其他 |
+----+------------+------+
3 rows in set (0.00 sec)

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
在struts2中有三种不为其指定回显保存方式可以将数据回传到jsp页面或struts.xml文件中?

	1.在Action中提供对应的字段,并为其提供set与get方法
	2.在Action中提供一个javaBean字段,并为其提供set与get方法
	3.是实现ModelDriver接口

	*特别提醒:对于这三种方式,我们可以不为其指定 回显保存方式 ,他们都默认放在对象栈的栈顶,而其他的没有保存在以上三种情况 中的数据,我们如何有回传数据,我们都应该将

		数据放在 stack context 的 命名对象 中,即用 ActionContext.getContext()....这种方式保存回传数据,我们用这种方式回传到jsp 或 struts.xml 中的数据在取用时
		
		我们应该在对应的取值名前加上 #,除此之外, 我们如果不用以上三种方式,但我们依然像将数据放在 stack context 的对象栈中,我们可用 ActionContext.getContext
		
		().getValueStack().push(object); <这种方式 回传保存数据 .如果用这种方式回传的数据与以上三种的任何一种情况一起使用时,由于它在栈顶,所有它会把以上中的任何	
		
		情况的值压倒对象栈的第二的位置>,(当然对于尖括号中的内容,暂时还是我的推理,我还没有去验证)
		
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	对于在Action中model的值传到了dao层中,我在dao层中改变了值,会影响到Actin中model的值吗?并且当model对应的方法返回到jsp 会 struts.xml时,是否可以直接使用model中的值?

	会影响到Action中的值,因为java中方法与方法之间的传递数据用的是指传递. 并且可以直接在 回传的 jsp 或struts.xml	页面中使用该model.其他情况也是同理的	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
关于FCKeditor的使用方法:	
	
		<form action="">
			<!-- -->
			<textarea name="content">abcdef</textarea>
			<!-- 2，在需要显示FCKeditor的地方写一段js代码 -->
			<script type="text/javascript">
				var oFCKeditor = new FCKeditor( 'content' ) ; // 参数是表示提交表单时所用的参数名
 				oFCKeditor.BasePath	= "./" ; // 这个属性必须指定，本属性表示editor文件夹所在的位置，必须要以'/'结尾
				oFCKeditor.Height	= 300 ;
				oFCKeditor.Width	= 600 ;
				oFCKeditor.ToolbarSet = "bbs"; // 默认是 Default 
				// oFCKeditor.Create() ; // 在当前位置创建并显示FCKeditor
				oFCKeditor.ReplaceTextarea(); // 替换指定id或name的<textarea>元素，显示为FCKeditor
			</script>
			<br><input type="submit" value="提交">
		</form>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
分页的页面中所要用到的字段:

	recordList		本页的数据列表
	currentPage		当前页
	pageCount		总页数
	pageSize		每页显示多少条记录
	recordCount		总记录数
	beginPageIndex		页码列表的开始索引（包含）
	endPageIndex		页码列表的结束索引（包含）

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何标记一个方法已过时;	

	@Deprecated
	List<Reply> findByTopic(Topic topic);

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
对<s:iterater>标签的使用说明:

	<s:iterator var="" begin="" end="" value="">
		
	</s:iterator>

	// 如果我们在<s:iterator var=""> 中使用了var属性,则表示将迭代出来的值放在 stack context 的 命名对象中 ,则我们在 下面的 struts的标签中使用时要加上 # ,当然了如果

	我们在没有使用struts的标签中使用,用EL表达式即可, 如果我们没有用var属性,这表示我们把遍历出来的值放在了 stack context 的 对象栈中 , 在struts的标签中我们直接使用
	即可,同理:当然了如果我们在没有使用struts的标签中使用,用EL表达式即可

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	获得总页数的经典算法:

	// 计算 pageCount
		pageCount = (recordCount + pageSize - 1) / pageSize;	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
三元表示的高级用法:

	public HqlHelper addOrder(String propertyName, boolean isAsc) {
		if (orderByClause.length() == 0) {
			orderByClause = " ORDER BY " + propertyName + (isAsc ? " ASC" : " DESC");
		} else {
			orderByClause += ", " + propertyName + (isAsc ? " ASC" : " DESC");
		}
		return this;
	}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
再用struts2时用url地址向Action发出请求时不用再加上 工程名,不管该标签时 不同标签 还是struts的标签,例如:

	<a href="user">添加用户</a>
	<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
下面的userService.editUser(user);为什么不能保存Model.
	User user=userService.getById(model.getId());
		if(model.getPassword()!=null&&!model.getPassword().equals("")){
			user.setPassword(model.getPassword());
		}
		user.setName(model.getName());
		userService.editUser(user);

	//因为此时的Session还没有关闭,所有只能更改从数据库查出来的对象.

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
用EL表示判断是否为空的高级用法:

	${!empty sessionScope.user?user.username:'游客'}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何用转发的方式跳到servlet

	<jsp:forward page="/VoteServlet?method=findAllVote"/> 

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
上传下载的关键代码与xml配置:

	上传Action

		private File uploadFile;
		private String uploadFileFileName;
		private String uploadFileContentType;  //要为这三个方法提供set与get方法
	
		String path=ServletActionContext.getServletContext().getRealPath("/upload");
		File file=new File(path,uploadFileFileName);
		uploadFile.renameTo(file);

	上传xml

		struts.xml没有任何特殊配置

	上传jsp

		<s:form action="upload_add" enctype="multipart/form-data">

................................................

	下载Action:

		private InputStream inputDownload;  
		private String filename;		/要为这两个方法提供set与get方法,同时要与xml中对应的名字相对应

		public String getDownloadFile() throws Exception {
			inputDownload=ServletActionContext.getServletContext()
			.getResourceAsStream(upload.getFilePath());
			return "download";
		}

	下载xml

		<result name="download" type="stream">
			<param name="contentDisposition">attachment;filename=${filename}</param>
			<param name="inputName">inputDownload</param>
		</result>

``````````````````````````````````````````````
	下载xml的第二种配置:

		<!-- 下载专用的结果配置 -->
			<result name="download" type="stream">
				<param name="contentType">application/octet-stream</param>
				<param name="inputName">inputStream</param>
				<param name="contentDisposition">attachment;filename="${#fileName}.doc"</param>
			</result>

``````````````````````````````````````````````
	下载xml的第三种配置:

		<!-- 下载专用的结果配置 -->
			<result name="downloadProcessImage" type="stream">
				<param name="contentType">image/png</param>
				<param name="inputName">inputStream</param>
			</result>

....................................................

	下载jsp

		<s:a action="upload_getDownloadFile?id=%{id}">下载</s:a>

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	
如何使用Log4j打印日志:

	配置文件log4j.properties

		### logger ###
		log4j.rootLogger=info,dest1,admin  //这里定义了日志的打印级别是info

		log4j.appender.dest1=org.apache.log4j.ConsoleAppender
		log4j.appender.dest1.layout=org.apache.log4j.PatternLayout
		log4j.appender.dest1.layout.ConversionPattern=%d{[yyyy-MM-dd HH:mm:ss]} %-5p %x -> %m%n


?
		log4j.logger.admin=info,admin  ////这里定义了日志的打印级别是info
		#log4j.additivity.admin=false

		log4j.appender.admin=org.apache.log4j.DailyRollingFileAppender
		log4j.appender.admin.File=d:/admin.log   //这指定了打印到什么的地方去
		log4j.appender.admin.Append=true
		log4j.appender.admin.layout=org.apache.log4j.PatternLayout
		log4j.appender.admin.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} -> %m%n

	java程序中:

		Logger logger=Logger.getLogger(UserServiceImpl.class);

		public void addUser(User user) {
			logger.error("-------------------添加任务是出错了----------------");
			this.userDao.addUser(user);
		}

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------	



















<=====================================================================================================================================================================> 
<=====================================================================================================================================================================> 

对于做myShopping of Ext4系统时的一些总结:
<=====================================================================================================================================================================> 

								总结
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
解决json 转换的There is a cycle in the hierarchy!异常的两种方法(使用的jsonjar包是:net.sf.json..):

	方法一:
	
	 //得到所有部门
      //返回json对象字符串
     public String getAllDep(){
		  List list = deptDAO.findAll();
		  JsonConfig config = new JsonConfig();
		  config.setExcludes(new String[]{"emps"});//除去emps属性
		  String json = JSONArray.fromObject(list, config).toString();
		  return json;
      }
	  
	方法二:
		
		JsonConfig config = new JsonConfig();  
		config.setJsonPropertyFilter(new PropertyFilter(){  
		public boolean apply(Object source, String name, Object value) {  
				if(name.equals("areas")) { //要过滤的areas ，Map对象中的  
					return true;  
				} else {  
					return false;  
				}  
			}  
		});                  
		JSONObject json = JSONObject.fromObject( ma , config); /// ma 为要转成json的 Map 对象 

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
分析There is a cycle in the hierarchy! 异常产生的原因(使用的jsonjar包是:net.sf.json..):

	1.首先,分析JavaBean
	
		public class Tree {
			private Long id ;
			private String text;
			private Boolean leaf;
			private Tree parent;
			private Set<Tree> children = new HashSet<Tree>();
		}
		
	2.其次我们来看看dao持久层
	
		public List<Tree> findAllForTop() {
			Session session = sessionFactory.getCurrentSession();
			List<Tree> treeList = session.createQuery(//
					"FROM Tree t WHERE t.parent is null")//
					.list();
			JsonConfig config = new JsonConfig();
			//config.setIgnoreDefaultExcludes(false);  //设置默认忽略
			//config.setExcludes(new String[]{"parent"});  
			String treeJson = JSONArray.fromObject(treeList, config).toString();
			System.out.println(treeJson);
			return treeList;
		}
	3.原因分析:
	
		通过以上的1和2我们可以看到其实产生 There is a cycle in the hierarchy! 这个异常的原因正式JavaBean中的属于parent属于与children属于一起使用了,
		
		而在dao持久层中当我们查询出 顶层(Tree)的 对象,由于使用了Hibernate的懒加载,所以可能会把 孩子层(Tree) 对象都查出来,这时我们用将JSONArray或JSONObject
		
		将这个查出来的顶层(Tree)对象及懒加载出来的 孩子层(Tree) 对象 都转换为 json 字符串 , 但是当转换到第一个孩子层(Tree)时,就会出现这种现象,第一个孩子的
		
		父亲(parent) 是顶层(TRee) 对象,顶层(Tree) 对象的 孩子(children) 是 第一个孩子层(Tree),这样这个转换就会永远的在这里循环转换中,所以抛出了这个异常.
		
	4.解决办法:
	
		只要让parent ,children 这两个属性中的一个不转换为json即可,具体做法是将 2 中的代码注释放开即可	

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
java中如何处理日期转换为json的方式(使用的jsonjar包是:net.sf.json..):

	见 "...\java\一些资料\java\json\常见需求及错误\net.sf.json 日期 时间 格式化 方法.docx" 文档.

	注意: 这里的 '...'暂时为 "F:\resources"

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------














<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------

																				tomcat 的问题

<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
当在启动tomcat是报了如下错误:

	Error occurred during initialization of VM
	Could not reserve enough space for object heap
	Error: Could not create the Java Virtual Machine.
	Error: A fatal exception has occurred. Program will exit.
	
	或
	
	Invalid maximum heap size: -Xmx4096m
	The specified size exceeds the maximum representable size.
	Error: Could not create the Java Virtual Machine.
	Error: A fatal exception has occurred. Program will exit.
	
	若是报了如上的两个错误,解决的办法是:
	
		1,若是在windows(Linux)系统下 , 那就在 catalina.bat(catalina.sh) 文件中修改 如下的参数,
		
		set JAVA_OPTS=-Xms512m -Xmx1024m -XX:PermSize=64M -XX:MaxNewSize=128m -XX:MaxPermSize=256m
		
		如下是对应的英文翻译:
		
		(1):初始化虚拟机时出错

			不能预留足够的空间来进行对象堆

			错误：无法创建虚拟机。

			错误：发生致命的异常。程序将退出。
			
		(2):无效的最大堆大小：- xmx4096m

			指定的大小超过最大可表示的大小。

			错误：无法创建虚拟机。

			错误：发生致命的异常。程序将退出。
			
		这时我们都是修改 -Xmx1024m 这数值的大小
			
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
安装Tomcat指定JDK
	
	对于Windows系统:
	
		修改Tomcat两个配置文件个配置文件，"tomcat/bin/catalina.bat" ,"tomcat/bin/setclasspath.bat"

					rem   TITLE           (Optional) Specify the title of Tomcat window. The default
			rem                   TITLE is Tomcat if it's not specified.
			rem                   Example (all one line)
			rem                   set TITLE=Tomcat.Cluster#1.Server#1 [%DATE% %TIME%]
			rem
			rem
			rem
			rem $Id: catalina.bat 947714 2010-05-24 16:57:18Z markt $
			rem ---------------------------------------------------------------------------

			rem 在这个地方增加这两行代码,这在Windows系统上已经测试通过了,也许在linux系统也实用(只是猜测)
			rem 注意: 这里的路径的斜杠一定要是 反斜杠(\) ,这里是针对Windows系统
			
			set JAVA_HOME=D:\soft\job\java\jdk\jdk1.7.0_71
			set JRE_HOME=D:\soft\job\java\jdk\jdk1.7.0_71\jre


	对于linux系统:
	
		修改Tomcat两个配置文件个配置文件，"tomcat/bin/catalina.bat" ,"tomcat/bin/setclasspath.bat"
		
				rem   TITLE           (Optional) Specify the title of Tomcat window. The default
			rem                   TITLE is Tomcat if it's not specified.
			rem                   Example (all one line)
			rem                   set TITLE=Tomcat.Cluster#1.Server#1 [%DATE% %TIME%]
			rem
			rem
			rem
			rem $Id: catalina.bat 947714 2010-05-24 16:57:18Z markt $
			rem ---------------------------------------------------------------------------

			rem 在这个地方增加这两行代码,这个还没有测试过,不知道在linux系统上是否可以用.
			
			export JAVA_HOME=/usr/local/java/jdk1.6.0_18
			export JRE_HOME=/usr/local/java/jdk1.6.0_18/jre


<---------------------------------------------------------------------------------------------------------------------------------------------------------------------
webservice的使用案例(jdk方式)

	服务端的开发:
	
		package cn.test.control;

		import javax.jws.WebService;
		import javax.xml.ws.Endpoint;

		import cn.test.domain.User;
		import cn.test.service.WebServiceService;
		import cn.test.service.impl.WebServiceServiceImpl;

		@WebService
		public class WebServiceTest{

			public static void main(String[] args) {
				/**
				 * 参数1：服务的发布地址
				 * 参数2：服务的实现者
				 */
				Endpoint.publish("http://192.168.0.156:6789/WebServiceTest", new WebServiceTest());
			}
			
			public User say(String username,String password){
				WebServiceService wss = new WebServiceServiceImpl();
				User user = wss.Say(username, password);
				return user;
			}

		}
		
	.................................................................................................................................................................
	 wsdl文件,在浏览器中输入该地址就可以看到该文件http://192.168.0.156:6789/WebServiceTest?wsdl
	 
	.................................................................................................................................................................
	然后在命令行中输入 D:\sss> wsimport -s . http://192.168.0.156:6789/WebServiceTest?wsdl
	
	然后回车即可.

	然后将 D:\sss 目录中生成的 文件夹拷贝到 另一个工程项目中,在创建一个App.Java的类即可条用
	
		//-<service name="WebServiceTestService"> //这个wskl中拷贝过来的
		WebServiceTestService wss = new WebServiceTestService();
		//-<binding name="WebServiceTestPortBinding" type="tns:WebServiceTest"> //这个wskl中拷贝过来的
		
		WebServiceTest wst = wss.getWebServiceTestPort();
		User user = wst.say("wulin", "123456");
		System.out.println(user.getUsername());
		System.out.println(user.getPassword());
	
	
<---------------------------------------------------------------------------------------------------------------------------------------------------------------------




















